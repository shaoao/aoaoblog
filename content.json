{"meta":{"title":"奥奥の探索日记","subtitle":"奥奥のCoding日志","description":"纯粹、热爱、勇敢、自由","author":"ShaoAo","url":"https://sawr.gitee.io","root":"/"},"pages":[{"title":"朋友","date":"2024-03-20T12:03:41.000Z","updated":"2024-04-28T07:27:41.713Z","comments":true,"path":"PY.html","permalink":"https://sawr.gitee.io/PY.html","excerpt":"","text":"常用· 朋友们· 每次编译时，随机排序 添加友链· 如果你想和我交换友链，可以在下方留言或者发送邮件给我1526464053@qq.com，格式如下： 123456{ &quot;title&quot;:&quot;博客名称&quot;, &quot;link&quot;:&quot;博客链接&quot;, &quot;img&quot;:&quot;博客头像链接&quot;, &quot;des&quot;:&quot;博客简介 } 如果可以的话，你可以把我的信息添加至您的博客友链： 123456{ &quot;title&quot;: &quot;奥奥の探索日记&quot;, &quot;link&quot;: &quot;https://sawr.gitee.io&quot;, &quot;img&quot;: &quot;https://cccimg.com/view.php/f8a4b6199c0c036da1f160b12d01f50d.jpg&quot;, &quot;des&quot;: &quot;闪耀的时代 会为你而来&quot; } 出于对彼此的尊重，我希望你的博客至少： 不存在过多的广告，不包含zz敏感以及违法内容，符合大多数人的道德标准 保证大部分内容原创，以及转载注明出处 Open &amp; Love &amp; Peace"},{"title":"文章归档","date":"2024-03-20T12:15:32.929Z","updated":"2024-03-20T12:15:32.929Z","comments":true,"path":"archive.html","permalink":"https://sawr.gitee.io/archive.html","excerpt":"","text":""},{"title":"关于","date":"2023-08-19T16:00:00.000Z","updated":"2024-04-06T06:43:10.087Z","comments":true,"path":"about.html","permalink":"https://sawr.gitee.io/about.html","excerpt":"","text":"一个用于记录个人成长、技术、生活的个人博客。 以前的往事· 在22年底就开始着手搭建一个个人网站，那时候并没有了解过多的框架，只是自己写了一个网站，然后我做的的网站不够成熟，里面只有主页和个人介绍做的比较还算美观，其他的就不太行了。 当时的写文章也不够成熟，那时没有想到用markdown来写文章，所以自己在代码里写，真的很无趣，所以后来就一直闲置了。 大概在23年二月份，入手了台阿里云服务器(现在还没过期，但是域名过期了)，使用体验还是非常不错的，了解到Hexo，使用Hexo来搭建博客确实里面拥有非常多的好看的模板，但是那时候一点经验也没有，搭建了一个但是有些看不懂，就又搁置了。 再后来我拿我这个服务器部署了一个自己写的前后端项目，自己用了一段时间也不用了，这台服务器也就一直闲置着。 慢慢的了解到Typecho才发现，这是一个轻量级的博客，然后后台也是非常的简洁轻巧，很不错，找到了几个主题也是非常的喜欢，接着就开始部署使用。 这个有一点好处，就是文章什么的都可以在线写，写了直接发布，评论管理什么的都自带的存在服务器上，就感觉这东西真方便，也是用了一段时间后。 由于学校里的比赛太忙，参加的比赛较多，没有时间更新，慢慢的就把这个博客给遗忘了，而且这台服务器也是快过期了，并且服务器对我来说用处不大，所以我不打算续费这台服务器。 也是由于服务器快到期的原因吧，所以我就想着，用之前了解过的VuePress来搭建自己的博客平台(之前使用该项目搭建过学习笔记)，所以记忆比较深刻，而且相对轻量，所以就自己折腾学习了一下。 静态博客的好处就是，代码都在面前，想怎么搞就怎么搞，写完直接推到GitHub上，也还是挺方便的，对这个VuePress的博客进行了一番魔改，然后就发布上线了，这是用了很久的一个。 最主要的还是这里比较自由，可以记录自己的成长，没有人会不喜欢有一个全都是自己的网站。 关于我✨· 一个不知名吉他手、白日梦想家，喜欢敲代码，喜欢研究技术,有一个很爱我的女朋友。 热爱 编程👨‍💻、吉他🎸、篮球🏀、音乐🎵、跑步🏃‍、风景🌆、摄影📷、骑行🚲… 有强迫症、懒癌、拖延症，喜欢折腾、喜欢折腾、喜欢折腾一些没用的东西… 喜欢摄影，时间定格本是神技，摄影让我们可以窥探神的技能。 喜欢摇滚，摇滚可以给我力量，摇滚会让我更加热爱生活。 会的一些东西· FrontEnd BackEnd 白日梦想· 带着相机，背上吉他，和喜欢的人一起旅行。"},{"title":"","date":"2024-04-06T05:22:58.127Z","updated":"2024-04-06T05:22:58.127Z","comments":true,"path":"custom.css","permalink":"https://sawr.gitee.io/custom.css","excerpt":"","text":":root { --color-shadow: rgb(204 177 161 / 60%); } body { overflow-x: hidden; } article p{ /* 行间距 */ line-height: 2.2rem; font-size: 17px; color: #2e405b; /* 字体描边-- */ text-shadow: 0 0 1px rgba(0, 0, 0, 0.2); } article figure { font-size: 1rem; } article img{ /* 居中图片 */ display: block; margin: 0 auto; width: 80%; height: 80%; box-shadow: 0px 0px 10px rgb( 35, 39, 46, 0.6); } article img{ /* 行间距 */ line-height: 2.2rem; font-size: 17px; } #nexmoe-content .nexmoe-post-footer { background-color: transparent; } iframe { width: 100%!important; } article ul li { line-height: 1.5rem; }"}],"posts":[{"title":"夜爬老君山","slug":"life/20240501","date":"2024-04-30T16:00:00.000Z","updated":"2024-04-29T13:23:40.233Z","comments":true,"path":"2024/05/01/life/20240501/","link":"","permalink":"https://sawr.gitee.io/2024/05/01/life/20240501/","excerpt":"","text":"乖乖的家乡就是洛阳，我们俩都没爬过山，想着五一去爬一爬老君山吧。 为什么要夜爬？· 挑战自我，体验夜晚登山的乐趣。 可以在海拔两千多米高的山顶看日出。 爬山很累，但是登顶的那一刻，我相信一些疲惫都会释放。 看太阳露出地平线。 和喜欢的人一起。 老君山攻略· 📍坐标：河南省洛阳市栾川县老君山风景区 🕰时间：24小时开放，随时可以入园；夜爬的开始时间是晚上10:30 - 11:00，所以夜爬这个点之前到就行了。凌晨3:30 - 4:30金顶会亮灯。 🎫门票：要提前三天预约！100/人，学生证半价，60岁以上老人以及12岁以下小孩免门票，最好要提前购票。，提前购票就是去美团或者微信公众号上去预约。 必备物品· 身份证原件(验票使用)，一定要带。 手电筒景区里面也可以买，10元一个，但是好像全程都会有人给你照亮的，因为爬山的人很多； 充电宝可能爬山过程不用，但是一定要带； 登山棍3元/根，5元两根，不要买太重的。 每人起码两瓶水，吃的带一些火腿肠，小面包、巧克力、自热米饭之类的，景区内的卖的要贵两三倍，山上没有热水，有也要钱。 衣服：早晚温差大，山顶要比山下低十来度，准备好短袖、卫衣、薄外套之类的，爬山的过程好像会热一些，只有山顶冷；可以带帽子以及墨镜，拍照片用；鞋子最好穿一个舒服一些然后防滑的鞋子。老君山有汉服租(30-50元一件)。 还想带两瓶啤酒，看日出标配嘛。 交通以及景区路线· 一般是坐火车到洛阳站，或者坐高铁到洛阳龙门站，这两个站点都是有大巴车，可以直接坐大巴车到洛阳栾川县，距离还是比较远的大约有100多公里，大约要坐三个小时车，大巴坐右边的沿途风景会更好。 坐大巴到景区之后，检票完了进来之后还有七八公里才能到达爬山出，景交大约20元，不坐的话会很累，把体力留给后半程。 索道· 一级索道有两条：中灵索道和云景索道，单上行70元，单下行65元，联票130元，选其中一条即可，一级索道最好要乘坐，17km山路，徒步预计5小时，沿途没有好看的风景，索道10分钟左右即达中天门。二级索道不用坐。 游玩路线· 游客中心 - 检票口 - 一级索道 - 中天门 - 十里画屏 - 马鬃玲 - 南天门 - 金顶。 游客中心 -&gt; 检票口 -&gt; 一级索道：全程大约八九公里，坐景区单程交通20元。 一级索道 -&gt; 中天门：坐索道10分钟，步行大约17公里山路，这个缆车必须要坐了。 中天门 -&gt; 十里画屏：步行1.5小时左右，风景比较优美。 十里画屏 -&gt; 金顶：皆为步程，大约2.5小时就能到达。 从中天门往后开始的点都是可以打卡的地点。 登顶游玩· 登顶之后可以玩的有：南天门、钟楼鼓楼、老君庙、祖师殿、道德府、金殿、亮宝台、玉皇顶。按照这个顺序挺好的。 预算准备· 事项 花费 老君山门票 50+50 = 100 来回大巴车*2 80+80 = 160 景区交通车*2 20+20 = 40 一级索道*2 75+75 = 150 零食 100 总计 大约600-700 加上一些突发情况，这个预算还可以，老君山冲！ !()[https://gitee.com/sawr/personalimage/raw/master/img/20240429211956.png] ![[ljs 1.jpg]]","categories":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://sawr.gitee.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"记录生活","slug":"记录生活","permalink":"https://sawr.gitee.io/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"},{"name":"爬山","slug":"爬山","permalink":"https://sawr.gitee.io/tags/%E7%88%AC%E5%B1%B1/"},{"name":"山野日志","slug":"山野日志","permalink":"https://sawr.gitee.io/tags/%E5%B1%B1%E9%87%8E%E6%97%A5%E5%BF%97/"}]},{"title":"我推荐的工具","slug":"tools/recommend","date":"2024-04-16T16:00:00.000Z","updated":"2024-04-23T05:15:51.173Z","comments":true,"path":"2024/04/17/tools/recommend/","link":"","permalink":"https://sawr.gitee.io/2024/04/17/tools/recommend/","excerpt":"","text":"在这里分享记录一下我所常用的工具，大多数都是有用的。 GitHub文件加速下载(很多工具需要用到这些服务进行下载)： GitHub 文件加速 - Moeyy Github 文件加速 | GitMirror 杂用工具· PDF橡皮擦· 顾名思义，比如PDF有些水印，但是用很多工具都没有办法去除，就可以用这个橡皮擦，来直接擦掉。 直接选择一个画笔，然后对着水印直接擦就好了，擦完就可以左上角Save PDF进行保存了。 下载地址：PDF橡皮擦1.9.4.4英文破解单文件版.exe - 蓝奏云 (lanzn.com) LocalSend 局域网传输工具· 在同一个Wi-Fi下最好用的传输工具，可以设置默认传输路径，可以手机和电脑进行文件传输。 一般在同一个Wi-Fi下，可以直接匹配到手机，然后就可以直接连接，选择文件点击手机名字就可以直接传输过去了，速度极快。 开源下载地址：Releases · localsend/localsend (github.com) PC下载地址：LocalSend-1.14.0-windows-x86-64.exe - 蓝奏云 (lanzn.com) 安卓Apk下载地址：LocalSend-1.14.0.apk - 蓝奏云 (lanzn.com) MacOS：LocalSend-1.14.0.dmg - 蓝奏云 (lanzn.com) 注：以上下载地址都同步最新版GitHub仓库地址版本。 TreeSize 硬盘空间分析· 可以直接选择分析磁盘，并且由大到小进行排序，可以详细的看到都是哪些东西占了你的内存空间，清晰明了。 下载地址：TreeSize.Pro.8.3.2.1665.x64 绿色版.zip - 蓝奏云 (lanzn.com) Windows超级管理器· 省流：Windows电脑必装软件。 拥有超多的实用功能，自启动管理，电脑配置一览等功能，软件体积只有几兆，但是功能很硬核。 下载地址：Windows超级管理器.exe - 蓝奏云 (lanzn.com) TTime 翻译软件· 最喜欢的一款软件，拥有划词翻译、OCR识别翻译、多个翻译源、极速翻译等功能，这就是一款非常全能的翻译软件。 超多翻译源 官网：TTime | 一款简洁、高效、高颜值的输入、截图、划词翻译AI软件 (timerecord.cn) 下载地址：安装使用 | TTime (timerecord.cn) Final2x 图像4倍高清放大工具· 软件一共大约600MB，使用本地进行计算的一款图片高清修复工具，上传文件然后点击开始，图片即可高清修复完成，全程本地工作，CPU或者显卡越好速度越快，RTX3060显卡大约15秒钟就可以完成四倍无损高清放大修复。 GitHub：Tohrusky/Final2x: 2^x Image Super-Resolution (github.com) 下载地址：Releases · Tohrusky/Final2x (github.com) 音乐工具· 作为一个音乐区UP，做音乐的工具是必须齐全的。 LX Music· 落雪音乐助手，在GitHub截至目前有36.6K Star，可见其实力强大，聚合了各大平台的搜索，但是要配合上音源来使用，这里推荐六音音源。 并且可以开启下载功能，最高支持FLAC无损格式，但是不支持24bit/192kHz最高频率下载。但是音质也是够用了。 音源：洛雪音乐助手自定义音源_v1.1.0_下载后请先解压 (1).zip - 蓝奏云 (lanzn.com) GitHub下载地址：Releases · lyswhut/lx-music-desktop (github.com) Adobe Audition 2024· 最强的音乐编辑器，降噪、人声增强、修复等等太多太多功能都需要用到AU来操作，这是必须要拥有的工具。 下载地址：阿里云盘分享 (aliyundrive.com) UVR5 伴奏分离· 很强的一款人声伴奏分离工具，不仅可以分离人声，还可以单独分离出Bass、Drums、Guitar等等，是一个非常好用的工具，需要魔法来下载模型，全英文，入门难度稍高，但是学会了非常好用。 开源地址：GUI for a Vocal Remover that uses Deep Neural Networks. 下载地址：Releases · Anjok07/ultimatevocalremovergui (github.com) Replay 伴奏分离· 或许是最好用的伴奏分离工具了，但是软件大小有点太大了，并且默认存储在C盘里，这样就导致你的C盘很容易满，因为这个软件大小有几十G，所以斟酌使用。 并且可以通过RVC模型来直接实现语音翻唱，还算实用，但是不太好用，没办法微调，所以还是老老实实分离完之后进行手动编辑这样效果最好。 官网：Replay | Free AI Voice Cloning and Stemming using RVC Models (tryreplay.io) 下载地址：Replay | Free AI Voice Cloning and Stemming using RVC Models (tryreplay.io) MKVTools 混音工具· 一个很好用的视频和音频混音的工具，当你有一个视频和一个高音质音频的时候，就可以使用这个来把视频和你的高音质音频进行混到一起，并且速度极快，1G的视频音乐大约只需要1秒就可以混音完成。 官网下载地址：MKVToolNix news – Matroska tools for Linux/Unix and Windows","categories":[{"name":"tools","slug":"tools","permalink":"https://sawr.gitee.io/categories/tools/"}],"tags":[{"name":"有用分享","slug":"有用分享","permalink":"https://sawr.gitee.io/tags/%E6%9C%89%E7%94%A8%E5%88%86%E4%BA%AB/"},{"name":"工具","slug":"工具","permalink":"https://sawr.gitee.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"关于郑州的五天四夜","slug":"life/20240403","date":"2024-04-02T16:00:00.000Z","updated":"2024-04-10T09:39:39.807Z","comments":true,"path":"2024/04/03/life/20240403/","link":"","permalink":"https://sawr.gitee.io/2024/04/03/life/20240403/","excerpt":"","text":"2024.03.29，出发去了郑州，这次出发是为了04.01的考试，但是一般来说提前一天就可以了，为什么提前这么多天去。 首先是蕊蕊对于这场升本考试，有着很大的压力，情绪一直都不太稳定很需要我。 其次是在30号有一场考前&quot;无声入场&quot;演练，但是这个其实没有什么用，只要你身上没有铁就好了，但是学校政策还是遵守。 在郑州呆了五天四个晚上，到现在的感觉就像在做梦一般，时间过得飞快，有意义的事情需要写下。 出发· 在29号起了个早，起来洗洗头然后洗洗漱很开心的早上，然后想想自己火车票是十点半的，起早也显得没那么重要了，还是比较晚才出去。 我妈起的比我还早，她总是很关注我的事情，早上怕我饿着肚子，还专门去给我买了包子，我一看，还是灌汤包(挺好吃就是有点贵)，简单的吃了几口就准备去等公交然后去火车站。 家里离火车站大概7.5公里，去等车结果公交车就一直不发车，我还是想提前去一会，然后就去寻找了一下青桔单车。 骑上以后我的运气爆好，因为我选择走大道，是笔直的路线可以最快到达，大约有十几个路口，但是红绿灯我只等了两个，几乎是一路绿灯，特别舒服。 上了火车之后，感觉还是很快的，但是还是晚点了40分钟，特别离谱，本来一点就可以到，愣是弄到了两点才到，而且没有任何的晚点消息，但是肯定是有些原因在的，可以理解。 到达· 到了郑州之后先去了酒店去放一下我的行李，我去洗了个澡，正好让女友多学会习，一举两得；这天真的很热，都快30°了，河南冷是真冷，热是真热。 另外今天抢薛之谦洛阳站，毫无意外的我们两个都没抢到。 到了晚上准备坐公交车去找女友，结果这条路上的公交车一小时一辆，我大约等了有40分钟，但是在这40分钟期间我一直在往女友那边的方向走，我走了40分钟感觉都快过去了结果公交车来了，那我还是上车比较爽。 一起去夜市买了点饭，等待着明天去学校。 3.30去学校· 这天起了个大早，洗洗漱就准备去学校，因为怕人比较多拥挤，所以就去的比较早，而且想坐公交车去，但是公交车和之前提到的一样，发车速度太慢了！！，选择打车了。 到学校第一件事就是去领准考证，先去了图书馆领我的，然后我突然想上厕所，女友正好去买笔了，我完事也正好选好了，哈哈，然后去了综合楼去领女友的准考证。 时间还早，领完了我们去图书馆坐了会，万事俱备，就差入场开始模拟了，大概到了十点多才开始，人超级多，还是那句话，堪比春运，进了安全门全身扫描一下，入场前检测一下衣服以及文具，没什么问题，就可以走人了，我俩都没什么问题。 乖乖和一个学妹买了许嵩&quot;呼吸之野&quot;演唱会的周边，有袋子什么的，还是非常好看的，那个学妹还送了一些护肤品之类的，人很好的一个小姑娘。 本来是准备和乖乖的朋友小赵和小赵对象一起去吃饭的，还给我俩买了奶茶，太客气了！下次见到必须也给她俩安排！希望你们爱情长长久久！由于人太多了而且也加上快清明商家都放假了，就没吃了。 然后我们准备去吃米村拌饭，在之前就已经想去吃了，正好这次弄完才不到十二点，时间完全够用，我们就去了新田360去吃啦，真的很火，我们等了十八桌才排到，但是好在吃到了！ 吃完大约差不多三点多了，该回去学习了，因为这些时间一刻也不能放松，本来准备兵分两路，乖乖去教室，我去酒店，但是已经三点多了回去要四点，在学学回来很麻烦也学不了几个小时，于是我们就直接一起回去了。 期间因为木有买草莓还有一些事情闹了些不愉快，但是还好被我补救过来啦，女朋友的情绪一定要照顾周到，且看我娓娓道来。 在路上乖乖特别的困，甚至都走不动了哈哈，在公交车上靠着我睡着了，然后头时不时的就滑下去了，但是我一直用手拖着乖乖的头！持续了20多分钟！直接让乖乖睡了一个好觉，下车后胳膊都麻木啦！哈哈哈，但是好开心呐！ 回去之后乖乖就在学习，我就在剪视频工作，很幸福，晚上吃了些东西然后就在给乖乖提问管理，很努力。 3.31安排· 31号早上，乖乖起了个大早，要回去教室学习努力奋斗搏一搏，我就多睡了一会，然后到了十点才起床，起床洗了个漱，然后就开始收拾东西，去之前的定的索普锐酒店，这个酒店的环境要比现在的这个好一些，风景也很好。 乖乖和我说要预约明天去学校的车，因为明天用车肯定很多人，所以不提前预约到之后直接打车的话，会很容易打不到车，乖乖还是很细心的，最后也预约到啦。 放心！ 我收拾了一些东西，两大包一个更重的包，我带了有电脑还有衣服什么的，比较重也比较容易塞满，还好有两个袋子，我大概是11.40收时候去退房间的，然后到外面吃了个饭，一直待到了下午一点多，不是想一直在那待着，是因为这公交车是真不来啊。 303公交车比漫长的季节还要漫长。 上了公交车之后，我就抓紧去酒店办理入住去了，不得不说大酒店就是不一样，里面的人好像蜂窝涌进来了，今天真的超级多人，唯一不变的一点是：都是来参加考试并且神情略带紧张。 进来酒店之后环境真的超好，整个感觉都不一样了，让整个人都充满了动力，让我突然想到了余华老师的那句话。 我觉得一个人成长的经历会决定其一生的方向，世界最基本的图像就是这时候来到一个人的内心深处，如同复印机似的，一幅又一幅地复印在一个人的成长里。 环境真的会让人的认知、心情等很多方面产生不一样的影响，这些影响也会让一些人默默的接受并适应，当你适应了这些，在改变也只能是一些基础的改变了。 把乖乖接过来之后，一个下午的安排就是，我剪视频工作，乖乖背管理背英语，这种轻轻的互相没有打扰的感觉，也很让我喜欢。 我们两个不会因为其中一个人的忙碌而感到无所事事，我们都在为以后努力着，事情做完了我们可以互相给彼此一个拥抱，当抱过之后会感觉所有的疲惫都没了，这或许也是恋爱的意义。 当然，因为昨天和乖乖有一些不愉快小矛盾！所以今天当然要抓住机会，给乖乖一个小小的惊喜！ 没有女孩子会拒绝小蛋糕，这是不会变的真理。 我给乖乖订一个四寸的纯动物奶油小蛋糕，两层水果夹心是可以选水果的，加上乖乖想吃草莓，就一层加了草莓(好吃)，一层加了芒果(中和一下)，这种搭配真的很不错！ 因为蛋糕是现做的，大约需要一个多小时才能送过来，这个时间段，我俩也是一直在忙各自的事情学习，但是我能看到乖乖的焦虑紧张感，所以这个小蛋糕来的太及时啦。 当乖乖看到小蛋糕的时候，脸上的疲惫直接没有啦，这是我直接就看出来的，我的女友是一个什么事都写在脸上的女人，但是我超喜欢这样。 我俩彼此许了一个愿望，我的愿望是：乖乖可以顺利上岸，以及我们俩和我们的家人都健健康康。 乖乖的就不知道咯，但是我的可以记录在此。 我拍的难看，但乖乖拍的好看，等她发给我在补上。 不得不说动物奶油真的很不错，一点也不会腻，吃完心情好多啦，我就开始给乖乖提问！ 等待着…考前的最后一个夜晚。 4.1考试当天· 今天好像是六点多起来的，起来洗洗漱，在六点半吧就收到了司机的电话说已经到了，但其实定的是7:15的车，所以司机师傅对于我们也真的很用心，知道考试，所以提前来了快一个小时，这一个小时完全可以接个两单，但是还是直接等着我们，所以我们很幸运。 作为经贸的传统，无论什么考试，对于孔圣的祭拜已经成了一种习俗，所以我们也拜了拜。 然后去了图书馆，开始最后的复习，临阵磨枪，不快也光。 考完买了杯咖啡提提神，英语不太难。 中午去吃了以前和乖乖一起喜欢吃的鸭鸭汤卖的酸汤水饺，女店主见到我之后说的第一句就是：“你好久没来了”，我说：“确实，但这不还是来了嘛”。 还说了说我的头发没以前长了，以前喜欢摇滚留了个很长的头发，当然现在也喜欢摇滚，天气太热就剪了。 随之，又是图书馆之旅，也是给乖乖把知识点全提问了一个遍，然后陪乖乖去修了一下手机正好把包什么的放在那。 考完啦· 考完之后我就在下面等着乖乖和我一起，然后去手机店拿手机啦，很开心的抱了抱，考得好与不好，从心情就能看出来，乖乖是特别开心的那种。 考试最大的开心莫过于&quot;考的全会&quot;吧，乖乖就是这种情况。 所以她很开心，我也很开心。 随后就是先回去收拾收拾东西，本来打算考完直接出去玩的，但是有一堆东西加上也没想好去哪玩，就先回去啦，回去以后休息了一会，我们就准备收拾一下东西给乖乖带过去。 顺便买了地府鸭货，其实就是他们家招牌是绿色的，绿光和黑夜就形成了一种类似地府的感觉，我和乖乖就取了个名字为&quot;地府鸭货&quot;。 收拾完我们就准备出发啦，这次去二七，一出门就看到了粉色的二七塔，确实很粉，旁边的花花好像还没开。吃了一顿火锅和关东煮，主要也是比较晚了，而且风很大。 吃完饭后· 吃完饭之后，已经是第二天啦，其实不知道为什么时间过的这么快，我俩有点后悔跑这么远了，于是就看了一眼地铁，发现三号线，有一个叫做橙跑计划的活动，不懂什么意思，但是就知道凌晨了还在跑着最后一班！ 于是我和乖乖我们俩就一路小跑安检，由于比较慌张，还不小心跑到了1号线，二七地铁站是一、三号线可转，于是我们又马不停蹄的跑到了3号线站台，此时工作人员也帮我们指引，感觉很温馨。 看到凌晨还有地铁等着我们的时候，感觉真的是非常温暖！郑州真不错奥！ 在这个点一路上我们只看见了两个人，一个应该是乘客吧，还有一个是地铁上的工作人员，这么晚了还在坚守岗位，为你们点赞！ 我们是到了莆田站下车，莆田站有两个出站口A、B，我们一开始去了B出站口，结果正好赶上了关地铁站的大门，然后那位叔叔就让我们去A口出站，然后我们刚出了A口正好有一个保安小哥也来了准备关A口的门，所以很幸运的出站了没有被锁在里面。 出来了还在下小雨，准备找共享单车骑回去，结果是一辆也没有了，打滴也是叫不到，可能是有点偏了，然后就索性把外套给乖乖穿上，然后一路走回去，全长大约1.4公里，走走也挺好的。 就这样，我们两个，下着雨，有大风很冷，在昏暗的城市道路上，一步一步的前行着。 马上走到地方了，就看到了共享单车成群成群的出现，真气人！ 国际友好手势送给你。 回来之后抱一抱缓解一下疲惫，我们两个脚丫子都走的很痛，洗了个脚，收拾收拾了东西，然后已经是一点半了。 我们准备看会周处除三害，乖乖之前学习太紧张，没有时间看电影，这其实已经是我看的第三遍了，但是后来由于乖乖太困了，就看了有四分之一，就睡着啦。 4.02· 今天睡了蛮久的，大约睡到了十点多，我们收拾了一下东西，然后准备再次前往二七，因为昨天去的时候比较晚，很多商场什么的都关门了，所以今天准备再次前往，而且距离火车站比较近。 依旧是共享单车骑到莆田，从莆田直达二七，到地方了，映入眼帘的就是一家益禾堂，但是无论买什么都送一张大乐透，乖乖也是直接安排了两杯，并且可以顺便领一张大乐透彩票(提前说：没中)。 旁边有一家三福店铺，而且是超大的，就和乖乖去逛了逛。 哎呀妈呀，我的宝宝也太好看啦，日常夸夸！逛了一会儿我们就去吃饭啦，这次还是吃的鱼你在一起，感觉没有第一次吃那么好吃了，但是也不错，米饭很好吃最起码哈哈。 在喝奶茶的时候，乖乖给我买的是牡丹花口味的，具体名字叫什么我忘记了，然后适合GGBond联名的还少，但是这个封口确实不太好看。 后来乖乖告诉我这个吸管很有来头，好像是霸王茶姬申请的专利，三根细细的管子可以让你越喝越香，以及喝起来会感觉很多，亲身体验，确实很不错，但除了包装。 吃完饭后好像才两三点吧，我买的是九点的火车票，所以时间还有很多，我们是在郑州二七亚细亚，里面待着的，今天正好有一个月老活动，有在唱歌的，在里面挺热闹不无聊。 亚细亚商场感觉真是郑州很棒的一个商场，不仅全楼层都有座位，而且商场内部有一种紧致的美感，总体来说就是很棒，很值得来。 我们就在座位上待着，然后睡了一觉，期间也是有一点点小矛盾，因为快要分开了，还有一些其他的原因，但是也解开啦，我们会好好在一起的。 睡醒了之后，乖乖说要去买点小吃的，我说我也跟着去，然后我们就去了负一楼，亚细亚商场七层有四层都是卖吃的，所以不愁吃。 乖乖喜欢吃百香林甜点，就买了三十块钱的糕点，真香哇。 有泡芙、麻薯什么的，我记不住反正很好吃哈哈哈。 到了六点多，那个活动开始抽奖了，乖乖参加了，他让我也参加，一开始是拒绝的，但是后来真香！ 我抽到了一份茄子，但是是冷冻的就没有吃，我问商家能不能加热一下，他们说回去可以自己加热一下他们这边现在不行，但没关系，也是一分收货。 乖乖抽到了一份小酥肉，真的很不错很香！吃完感觉都饱了，还喝了茶在这个店铺里面。 吃完了本来打算去大卫城的，但是步行有点远加上也快没时间了，就没有去。 乖乖就带我去了一个超市，因为我快走了准备给我买点吃的，乖乖对我很用心，我也很喜欢她。 买了一些吃的，很不错，我都很喜欢，喝汽水，喝大窑！ 乖乖问我什么味的，我说好像是大窑味的，真没注意过哈哈，原来是橙子味的。 在这里坐了一会，就要出发去车站了。 车票紧张，买的是站票无座的，但是买到了复兴号，就是高铁，我这波属于是花了火车的价钱然后做到了高铁的速度，环境也是高铁的环境，我也不清楚怎么会这样。 但是我是无座，所以就不管那么多了，找了个高铁的卧铺旁边，就是一站，不太拥挤，后来索性直接坐那了。 在里面呆着也挺有意思的，可以看到乘务员忙忙碌碌工作的样子，想想什么也都挺不容易的，向前走就对啦！ 晚上11点，慢节奏小城市，我终于回来啦！ 下了场小雨，因为在高铁里面热的要死，出来后感觉很爽，加上我晕出租车，没有打滴滴，准备扫了一辆青桔电动车回家。 来的时候是青桔，回去当然也要是青桔啦！ 或许是青桔知道我喜欢他们，这一单也不知道为什么，给我免单了，你如果这样的话！那我以后可只骑青桔了(以前也是)！ 差不多晚上十一点半吧，还在下下雨，走到了小区楼下，这感觉真美呀，真是一场酣畅淋漓的旅程！ 回到家，妈妈也给我热了饭菜在等我，金豆也在笼子里玩耍。 边吃饭边和妈妈说说话，感觉生活真的很美好，你要享受生活，感受生活！ 于2024.04.06下午ShaoAo写完于此。 Share This photo·","categories":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://sawr.gitee.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"记录生活","slug":"记录生活","permalink":"https://sawr.gitee.io/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"},{"name":"学习","slug":"学习","permalink":"https://sawr.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"Vue3学习笔记","slug":"vue/vue3study","date":"2024-03-03T16:00:00.000Z","updated":"2024-04-10T09:07:10.476Z","comments":true,"path":"2024/03/04/vue/vue3study/","link":"","permalink":"https://sawr.gitee.io/2024/03/04/vue/vue3study/","excerpt":"","text":"最近想复习一下Vue3的整体过程，打算重新学一遍的Vue3+TS的教程，现在准备开始学，并且做好笔记。 Vue3官网 Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org) 尚硅谷笔记链接大全：资料 一共是71集，全长大约14个小时，从2024.03.04下午16:30开始学习，至此，开始记录。 编码规范为：TS+组合式API+Setup语法糖 Webpack和Vite的构建区别· Webpack：从入口进入，先扫描路由，然后扫描每一个模块，然后开始bundle，最后ServerReady，也就是说不管你用不用到的东西，都给你加载了，然后再给你看结果，就会比较慢。 Vite：我直接给你看结果，你想看哪个我给你加载哪个，等于变聪明了。 一句话：Vite比Webpack快。 Vue3创建步骤· 1npm create vue@latest 然后根据所需进行配置即可。 然后 12345678cd &lt;your-project-name&gt; npm install npm run dev #or yarn yarn dev 项目整体文件介绍· .vscode - extensions.json ：表示所需要安装用到的扩展插件. 删了也没事,但是留着也不占地方. env.d.ts:这里面的配置代码,主要目的就是让TS认识各种类型的文件. 例如css,sass,jpg等各种类型的文件. index.html:项目的入口文件,通过该文件引入的src/main.ts文件,可以让整个项目跑起来 vite.config.ts:整个项目的配置文件,可以配置插件,代理等之类的 src/main.ts简单介绍 在 Vue 3 中，createApp 是用来创建一个 Vue 应用实例的工厂函数。 import &#123; createApp &#125; from 'vue' 这行代码是导入了应用的根组件。 import App from './App.vue' 把vue挂在到指定元素上 createApp(App).mount('#app') 结构· 选项式API和组合式API· 选项式API一般是在Vue2中使用. 白色框这些都属于是配置项,也就是选项式API,学Vue2就等于是在学这些配置项。 选项式API的英文名叫OptionsAPI，但是在Vue3中提出了一种新的组合式API(CompositionAPI) 。Vue2的API是OptionsAPI风格的。Vue3的API是CompositionAPI风格的。 OptionsAPI(选项式API)的弊端就是，数据、方法、计算属性等等都被拆分开了，当你需要改动一个东西的时候，那么你就需要同时在Data、methods等等这些方法里面去修改，不便于修复和维护。 CompositionAPI(组合式API)把一个整体都放在一个函数方法里(Function)，这样很符合逻辑而且也方便维护。 Vue3 核心语法· Setup· Setup是Vue3中的一个新的配置项，它的值是一个函数，他是CompositionAPI&quot;表演的舞台&quot;，组件中所有用到的数据、方法、计算属性、监视…等，均配置在Setup里面。 Vue2的代码 1234567891011121314151617&lt;script lang=&quot;ts&quot;&gt; export default { name:&#39;Person&#39;, data(){ return{ name:&#39;张三&#39;, age:18, tel:&#39;12345678901&#39;, } }, methods:{ showTel() { alert(this.tel) } } } &lt;/script&gt; 改为Vue3数据编写方法更集中了，但是如果通过方法来更改参数的值，那么会改变值但就不是响应式数据了,就无法同步到页面中。 1234567891011setup() { // setup函数中的this是undefined，因为setup函数本身没有this，vue3开始弱化this了。 // 此时的name、age、tel都不是响应式的数据。 let name = &#39;张三&#39; let age = 18 let tel = &#39;123456789&#39; function showTel() { alert(tel) } return {name,age,showTel} } setup函数的返回值也可以直接是一个渲染函数，可以直接指定渲染的内容，例如 1234setup() { return () =&gt; &#39;你好&#39; } 此时的页面上就会只显示你好这两个字，之前写的div之类的都没有用了，但是这个是不常用的。 Vue2中的语法比如data、methods是可以和vue3中的setup共存的，但是vue2的data、methods等，是可以通过this来调用setup里面的数据的，但是setup调用不了vue2其中的数据。 setup语法糖· 语法糖说白了就是更简单的写法。 在script标签中，我想要无非就是数据以及函数方法，但是每个都还要进行导出，假如数据量比较大，其中一个我忘记return导出了，那岂不是出现很大的问题了，而且多了要一一导出代码也看着比较臃肿，所以就有了这个东西setup语法糖，至于为什么叫这个，我估计是这样写起来会有种尝到甜头的感觉，很方便。 于是代码就变成了这样，所有的数据以及函数都不需要导出了，就很方便。 name名称插件· 这样写看着也有些麻烦，写了两个script，但可以通过一个官方插件来缩短成一个script，开发依赖，所以加上-D 1npm i vite-plugin-vue-setup-extend -D 然后在vite.config.ts中引用，注意两个白线的地方。 此时就可以只写一个script了 这种写name的情况可以应对，有时候公司的组件会写成文件夹名/index.vue，这种情况，就可以使用name来区分。 响应式数据· ref创建基本类型响应式数据· 在vue2中，你的数据只要是写在data()里面，那么就默认是响应式数据。 ref reactive可以构建对象类型响应式数据也可以构建基本类型响应式数据。 首先引用ref 1import {ref} from &#39;vue&#39; 然后你想让哪个数据变成响应式数据就用ref包裹住。 1let name = ref(&#39;张三&#39;) 此时name就已经变成了一个响应式数据，所谓响应式数据就是你在修改这个name值的时候，在页面上会同步更新，很方便。 此时如果console.log打印一下name的话，那么就会发现已经变成了一个对象，但是在引用的时候不需要加.value，因为vue3会自动帮你加。 但是在JS以及TS中！必须要写.value！不然将会无法操作这个值！ ref也可以对对象类型进行创建响应式数据，和reactive一样，也是直接包裹住即可，但是当你在JS以及TS中进行调用的时候，值得注意的是.value的位置 123456789// 对象 function changePrice() { car.value.price += 10; } // 数组 function changeArr() { arr.value[0].name = &#39;王五&#39; } reactive 构建对象类型响应式数据· 1import { reactive } from &#39;vue&#39;; 此时对于一个对象类型的数据，也变成响应式数据了 1234let arr = [ { name: &quot;张三&quot;, age: 18 }, { name: &quot;李四&quot;, age: 20 }, ]; 数组也是同样的包裹，此时该数组也变成响应式数组了，可以直接更改arr[0].name = '王五'，此时页面也会进行渲染。 reactive也是深层次的，不管数据内嵌套了多少层，知道找到了就可以变成响应式。 reactive包裹的对象打印出来一般是Proxy开头。 而ref包裹的对象打印出来一般是RefImpl开头。 ref表面上什么类型都可以处理，但是对于对象类型，底层还是通过reactive实现的。 ref和reactive的区别· ref的.value每次都要手写，就很麻烦，如果忘了可能又是一个bug，所有volar插件提供了一个功能，可以在vscode的设置中找到 一开始是没有勾选的，给它勾上就行了。 reactive重新分配一个对象，就会失去响应式。 123456let car = reactive({ brand: &quot;奔驰&quot;, price: 200 }); // 修改整个对象 function changeCar() { car = {brand: &quot;仰望&quot;,price:220} } 如果这样，那么car将会失去响应式数据效果，那么应该如何解决这种情况。 只需要使用Object对象的assign方法进行整体替换，如果有多个对象那么都是添加到第一个参数上。 123456let car = reactive({ brand: &quot;奔驰&quot;, price: 200 }); // 修改整个对象 function changeCar() { car = Object.assign(car,{brand: &quot;仰望&quot;,price:220}) } 但是如果使用的是ref进行定义响应式数据，就可以直接进行更改，可以理解为只要是带.value那么就必然是响应式数据，无论基础类型还是对象类型。 torefs和toref· torefs：把一个reactive所定义的所有对象都变成一个ref所组成的对象。 123456let person = { name:&#39;张三&#39;, age:18 } let {name,age} = toRefs(person) 上面的代码，如果在 =后面没有加toRefs那么name和age将不会是响应式数据，并且修改nage和age也会同步修改person.name和person.age。 toref：可以单独拎出来reactive定义的对象中的一个数据，并且也变成ref响应式数据。 computed计算属性· 在Vue3中computed是一个函数，需要引用使用，computed拥有缓存，比function函数要聪明一些，例如要进行计算一个名称首字母大写。 1234567import { ref,computed } from &#39;vue&#39;; let firstName = ref(&#39;zhang&#39;) let lastName = ref(&#39;san&#39;) let fullName = computed(()=&gt; { let full = firstName.value.slice(0,1).toUpperCase() + firstName.value.slice(1) + &#39; &#39; + lastName.value return full }) 此时在页面上调用fullName即可出现首字母大写的名字组合，如果多次调用也只会计算一次，因为当computed是带有缓存的，但是这个是只读的，不能修改。 可读可写响应式数据需要调用get、set方法，set是带参数的，参数则是fullName的值 123456789let fullName = computed({ get(){ return firstName.value.slice(0,1).toUpperCase() + firstName.value.slice(1) + &#39; &#39; + lastName.value }, set(val){ firstName.value = val.split(&#39; &#39;)[0] lastName.value = val.split(&#39; &#39;)[1] } }) 简单来说就是如果需要从多个数据中重新计算出来一个新的，就用computed计算属性就可以了，计算属性计算出来的数据也是一个ref响应式数据 watch 监视· 1.监视ref定义的基本类型数据· 首先还是引用watch，然后定义一个sum = ref(0) 123watch(sum,(newValue,oldValue)=&gt;{ console.log(&#39;sum变化了&#39;,newValue,oldValue） }) 当你改变了sum值后，数据结果为 123sum变化了 1 0 sum变化了 2 1 sum变化了 3 2 重点：在vue3中watch函数返回一个用于停止监控的函数，这个返回的函数就是用来取消监控的，从而停止执行回调函数。 例子：当sum大于10的时候停止监控 12345const stopWatch = watch(sum,(newValue,oldValue)=&gt;{ if (newValue &gt; 10) { stopWatch(); } }) 2.监视ref定义的对象类型数据· 监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视。 前面使用的时候只调用了watch函数的前两个参数，开启深度监视就需要添加第三个参数，假设sun是一个对象数据，那么代码为： 123watch(sum,(newValue,oldValue)=&gt;{ console.log(&#39;sum变化了&#39;,newValue,oldValue） },{deep:true}) // 深度模式为真 这样无论是修改整个对象数据，还是修改对象属性都会被监视。 第三个参数，是类似于配置项的参数，有多个配置，比如 12// deep：深度模式 immediate：立即监视 {deep:true,immediate:true} watch的第一个参数：被监视的数据 watch的第二个参数：监视的回调 watch的第三个参数：配置对象(deep、immediate等…) newValue**,oldValue打印出来的值是相同的，这个问题的原因是地址值没有变，在打印出来的时候还是原来的地址，所以会相同，房子没换，换了壁纸和沙发。 3.监视reactive定义的对象类型数据· reactive是默认开启深度监视的，所以可以直接监视对象内部属性的变化，无需开启深度模式，但是也是不可以关闭的，官方说话：隐式创建深度模式。 watch函数和function一样都可以写多个。 4.监视ref或reactive定义对象类型数据中的某个属性· 若监视对象类型的某个属性是基本类型，需要写成函数形式(箭头函数) 可以在watch的第一个参数中，使用箭头函数来监视对象中的具体的一个值，比如 123watch(() =&gt; {return state.count}, (newValue, oldValue) =&gt; { console.log(`count 值从 ${oldValue} 更新为 ${newValue}`); }); 但是大括号和return是可以省略的于是就可以直接 123456789101112import { watch, reactive } from &#39;vue&#39;; const state = reactive({ count: 0, message: &#39;Hello!&#39; }); watch(() =&gt; state.count, (newValue, oldValue) =&gt; { console.log(`count 值从 ${oldValue} 更新为 ${newValue}`); }); // 修改 count 的值会触发 watch 的回调 state.count++; 但是如果监视的对象数据的属性是对象类型，可以直接写，也可以写成函数，但是建议写成函数，如果要监视对象类型的属性的细枝末节内部变化，需要手动开启深度模式deep:true。 5.监视上述的多个数据· 监视多个数据，通过使用数据包裹起来即可，还是普通数据用函数，对象数据建议函数也可以直接使用。 1234 // 监视，情况五：监视上述的多个数据 watch([()=&gt;person.name,person.car](newValue,oldValue)=&gt;{ console.log(&#39;person.car变化了&#39;,newValue,oldValue) },{deep:true}) watchEffect· 官网：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。 就是刚开始就会执行一次，你不需要明确给我提出具体要监控谁，你要用到谁我就自动监控谁。 watch对比watchEffect 都能监听响应式数据的变化，不同的是监听数据变化的方式不同 watch：要明确指出监视的数据 watchEffect：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。 1234567891011121314151617181920212223// 用watch实现，需要明确的指出要监视：temp、height watch([temp,height],(value)=&gt;{ // 从value中获取最新的temp值、height值 const [newTemp,newHeight] = value // 室温达到50℃，或水位达到20cm，立刻联系服务器 if(newTemp &gt;= 50 || newHeight &gt;= 20){ console.log(&#39;联系服务器&#39;) } }) // 用watchEffect实现，不用 const stopWtach = watchEffect(()=&gt;{ // 室温达到50℃，或水位达到20cm，立刻联系服务器 if(temp.value &gt;= 50 || height.value &gt;= 20){ console.log(document.getElementById(&#39;demo&#39;)?.innerText) console.log(&#39;联系服务器&#39;) } // 水温达到100，或水位达到50，取消监视 if(temp.value === 100 || height.value === 50){ console.log(&#39;清理了&#39;) stopWtach() } }) 标签的ref属性· 作用：用于注册模板引用。 用在普通DOM标签上，获取的是DOM节点。 用在组件标签上，获取的是组件实例对象(函数)。 用在普通html标签上，是直接获取dom元素内容 用在组件标签上，需要通过引入defineExpose来导出内容 123456789101112131415161718192021222324252627282930&lt;!-- 父组件App.vue --&gt; &lt;template&gt; &lt;Person ref=&quot;ren&quot;/&gt; &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt; import Person from &#39;./components/Person.vue&#39; import {ref} from &#39;vue&#39; let ren = ref() function test(){ console.log(ren.value.name) console.log(ren.value.age) } &lt;/script&gt; &lt;!-- 子组件Person.vue中要使用defineExpose暴露内容 --&gt; &lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt; import {ref,defineExpose} from &#39;vue&#39; // 数据 let name = ref(&#39;张三&#39;) let age = ref(18) /****************************/ /****************************/ // 使用defineExpose将组件中的数据交给外部 defineExpose({name,age}) &lt;/script&gt; TS中的接口、泛型、自定义· @符号会直接跑到项目的根目录，从而方便引入。 接口· 在TS使用接口来限制规范，新建一个 引用然后可以看到，如果我们设置的数据和接口设置的不一样，那么就会出错 如果是定义数组的话那就需要用到泛型 12345let personList:Array&lt;Person&gt; = [ { id: &quot;13&quot;, name: &quot;张三&quot;, age: 18 }, { id: &quot;14&quot;, name: &quot;李四&quot;, age: 19 }, { id: &quot;15&quot;, name: &quot;王五&quot;, age: 20 } ] 代码意思是，数组中的每一项都要符合这个数据规范，所以用到了Array，多个泛型在Person后面直接加就行，比如：Array&lt;Person,Student,Order&gt; 还有一种方法就是用到自定义类型 12345678910111213// 定义一个结构，用于限制person对象的具体属性 export interface Person { id:string, name: string, age: number } // 定义一个自定义类型，用于处理数组对象的具体属性 export type Persons = Array&lt;Person&gt; //or export type Persons = Person[] 可选· 在定义接口的时候，如果有些属性是可选的可以后面+?，比如年龄可选，此时加上?以后，age参数可以不写 123456// 定义一个结构，用于限制person对象的具体属性 export interface Person { id:string, name: string, age?: number } 如果是响应式数据reactive，可以这样 props· 首先引入defineProps 1import {defineProps} from &quot;vue&quot; 然后就可以接收父组件传过来的内容，必须要用数组来接收。 1234// 只接收 defineProps([&quot;list&quot;]) //接收同时保存props，此时的x会把所有props返回值都接收 let x = defineProps([&quot;list&quot;]) 只接收+限制类型 这样更加严谨，标明我需要收到一个list，并且这个list必须是符合之前写的Persons接口标准的list，当开启这种限制以后，如果父传过来一个别的数据那么是传不过来的，切父组件必须传list过来。 123import {type Persons} from &quot;@types&quot; defineProps&lt;{list:Persons}&gt;([&quot;list&quot;]) 接收 + 限制类型 + 限制必要性 + 指定默认值 当在list后面加上了一个?就可以让父组件可传可不传了。 但是如果不传数据，可以加一个默认值，在vue中引入withDefaults 12345import {withDefualts} from &quot;vue&quot; import {type Persons} from &quot;@types&quot; withDefults(defineProps&lt;{list?:Persons}&gt;(),{ list:()=&gt; [{ id: &quot;12&quot;, name: &quot;张三&quot;, age: 18}] }) 这种做法通常用于在组件中定义默认的 props 值,以防止在使用组件时没有传入 props 导致错误。如果组件接收到了 list prop,它将使用传入的值;如果没有传入 list prop,则会使用默认提供的值 [&#123; id: '12', name: '张三', age: 18 &#125;]。 define开头的函数，其实可以不用引入，因为是宏函数可以直接拿来用。 生命周期· 组件的生命周期(生命周期函数、生命周期钩子) 时刻 调用特定的函数 创建 created 挂载 mounted 更新 销毁 vue2的生命周期· beforeCreate（创建前）： 你可以在这个阶段做些准备工作，但是此时还没有真正创建 Vue 实例。也就是说，Vue 实例还没有被初始化。 created（创建后）： Vue 实例被创建好了，但是此时还没有开始创建真正的 DOM。你可以在这个时候做一些数据的初始化工作，或者请求一些初始数据。 beforeMount（挂载前）： 这个阶段是在 Vue 开始把你的页面内容放到 DOM 中之前调用的。你可以在这里做一些DOM准备工作。 mounted（挂载后）： 这时候 Vue 实例已经挂载到了页面上，你的页面已经显示了 Vue 组件的内容。通常你可以在这里做一些需要操作 DOM 的工作，比如初始化页面后的一些动画效果。 beforeUpdate（更新前）： 在数据更新但页面尚未重新渲染时调用。你可以在这里做一些在更新前需要的操作，比如对比更新前后的数据。 updated（更新后）： 数据已经更新，页面也已经重新渲染完毕。你可以在这个阶段做一些需要最新数据的操作，比如更新一些在页面上显示的内容。 beforeDestroy（销毁前）： 当你要销毁 Vue 实例之前调用。你可以在这里做一些清理工作，比如取消定时器、移除绑定的事件等。 destroyed（销毁后）： Vue 实例已经被销毁了，这时候你的 Vue 实例上的所有东西都被清理掉了。你可以在这里做一些最后的清理工作，确保你的组件在销毁时没有留下任何垃圾。 这些生命周期函数钩子的调用顺序是这样的： 创建阶段：beforeCreate -&gt; created 更新阶段：beforeUpdate -&gt; updated 销毁阶段：beforeDestroy -&gt; destroyed vue3生命周期· 创建 vue3的创建阶段已经包含在了setup函数中，所以可以直接在setup进行打印输出查看。 12345&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt; console.log(&quot;创建&quot;) &lt;/script&gt; 挂载 首先引入，其实就是vue2中的beforeMount前面加了个on，然后B大写了。挂载完毕也同样是。 1import {onBeforeMount,onMounted} from &#39;vue&#39; vue3在挂在会会调用onBeforeMount函数所指定的函数，所以需要传入一个回调函数。 12345678// 挂载前 onBeforeMount(()=&gt;{ console.log(&quot;挂载前&quot;) }) // 挂载完毕 onMounted(()=&gt;{ console.log(&quot;挂载后&quot;) }) 在父子组件中都有挂载函数时，子组件先挂载完毕。 更新 跟之前同样，也是前面+on 1import {onBeforeUpdate,onUpdated} from &#39;vue&#39; 同样原理。 12345678// 更新前 onBeforeUpdate(()=&gt;{ console.log(&quot;更新前&quot;) }) // 更新完毕 onUpdated(()=&gt;{ console.log(&quot;更新完毕&quot;) }) 卸载 在vue2中叫做销毁，但是在vue3中就叫卸载 1import {onBeforeUnmount,onUnmounted} from &#39;vue&#39; 同样原理。 12345678// 卸载前 onBeforeUnmount(()=&gt;{ console.log(&quot;卸载前&quot;) }) // 卸载完毕 onUnmounted(()=&gt;{ console.log(&quot;卸载完毕&quot;) }) 卸载的效果可以通过v-if或v-show来确定展示与否来测试。 自定义hooks· 使用axios来请求一个数据 12345678async function getData() { try{ let result = await axios.get(&quot;api地址&quot;) List.push(result.data.message) } catch (error) { alert(error) } } async和await解析· 解析：这是一个名为 getData 的异步函数,主要用于从某个 API 地址获取数据。 async function getData() &#123; ... &#125; 这是一个异步函数声明，async关键字表示这个函数会返回一个Promise对象。这意味着函数内部可以使用await关键字，它可以等待一个异步操作（如HTTP请求）完成，然后再继续执行。 try &#123; ... &#125; catch (error) &#123; ... &#125; try块用于捕获可能发生的异常。如果异步操作成功，代码将正常执行；如果发生错误，控制流将跳转到catch块来执行代码。 let result = await axios.get(&quot;api地址&quot;) 这行代码是异步操作的核心，使用了 Axios 库发送一个 GET 请求到指定的 API 地址,并使用 await 暂停等待响应结果，直到HTTP请求完成。请求完成后，响应数据被赋值给变量result。 List.push(result.data.message) 这一行将 API 响应数据中的 message 属性值添加到一个名为 List 的数组中。它将result对象中的data属性的message字段添加到List数组中。这通常用于将获取的数据存储起来，以便后续使用。 catch (error) &#123; alert(error) &#125; 如果在执行 axios.get 时发生了错误,就会执行 catch 代码块中的语句,这里是使用 alert 函数在浏览器中弹出一个警告框,显示错误信息。error变量将包含错误信息。 hooks的功能就是，让一个功能数据、方法都贴在一起，从而方便阅读。 一般是以useXXX来命名，比如useOrder、useSum。 具体就是新建一个hooks文件夹，然后把每一个函数的功能以及所用到的数据，都放在这个以useXXX来命名的.ts文件里，代码正常写，但是需要默认导出，以及最后return一个值。 hooks/useOrder.ts 1234567891011121314151617// 正常引用所需要的东西 import {reactive} from &#39;vue&#39; // 最好默认导出 export default function() { // 数据 ... // 方法 ... // 钩子 ... // 计算属性 ... // 向外部提供东西，一般是数据、方法等。 return {orderList,getOrder} } 然后在原文件中进行调用 12// 首先引入，多个的话就挨个引入多个 import useOrder from &#39;@/hooks/useOrder&#39; 因为hooks的本质就是一个一个可以调用的函数，所以可以直接解构，因为useOrder是有返回值的。 1const {orderList,getOrder} = useOrder() 这样写的好处在于，方便维护，假如以后要维护这个订单相关的代码，那么只需要维护好这个订单hooks就好了。 因为有了hooks，那么compositionAPI才发挥出了真正的威力。 路由· 首先说明，站在程序员的角度，路由是路由，路由器是路由器。 路由的英文名叫：route，路由器的英文名叫：router，带r的是路由器，不带的是路由，这两个有很大的区别。 路由就是一组key-value的对应关系，多个路由需要经过路由器的管理，一般在SPA应用上比较多。 SPA应用简单来说就类似于后台管理系统的那种单页面切换。 路由有一个核心的东西就是路径在变localhost:8080/xxx。 学习路由使用步骤 导航区、展示区 请来路由器 安装路由 1npm i vue-router 涉及到路由，就必须有router这个文件夹，因为我们使用标准文件划分，并且指定制定路由事要想好路由器的工作模式。 Vue Router 提供了两种路由模式：history 和 hash。这两种模式主要区别在于 URL 的显示方式和浏览器历史记录的管理方式。 Hash 模式(哈希模式)：在这种模式下，URL 中会包含一个 # 符号，例如 http://example.com/#/home。这个 # 后面的部分（hash）不会发送到服务器，它只是客户端用来跟踪应用状态的一种方式。当用户点击浏览器的后退按钮时，应用会根据 URL 中的 hash 值来显示相应的视图。createWebHashHistory History 模式：这种模式提供了一种更自然的 URL 体验，没有 # 符号，例如 http://example.com/home。在这种模式下，Vue Router 会利用 HTML5 History API 来实现干净的 URL。这意味着 URL 的变化会被浏览器记录在历史记录中，用户可以使用浏览器的前进和后退按钮来导航应用的不同视图。createWebHistory router/index.ts 1234567891011121314151617181920212223242526272829303132// 创建一个路由并且暴露出去 // 第一步：引入createRouter import {createRouter,createWebHistory} from &#39;vue-router&#39; // 引入一些可能要呈现的组件 import Home from &#39;@/components/Home.vue&#39; import News from &#39;@/components/News.vue&#39; import About from &#39;@/components/About.vue&#39; // 第二步：创建路由器,一个路由器可以管理多个路由 const router = createRouter({ // 路由器工作模式 告诉vueRouter 使用history模式 history:createWebHistory(), // 写一个名为routes的配置项 routes:[ { path:&#39;/home&#39;, component:Home }, { path:&#39;/news&#39;, component:News }, { path:&#39;/about&#39;, component:About } ] }) // 最后暴露出去router export default router 然后回到main.ts中去引用路由 src/main.ts 12345678910// import ... // 文件名为index可以省略 import router from &#39;./router&#39; // 使用路由器 app.use(router) // 挂载整个应用到app容器中 app.mount(&#39;#app&#39;) 此时配置完毕以后，就已经用拥有了路由环境。 展示文件，RouterView用于展示文件，RouterLink用于切换文件。 RouterView会自动把切换到的.vue文件进行展示。 RouterLink 用于切换，其中 to=&quot;/xxx&quot; 用于写切换路径 active-class=&quot;css样式&quot; 表示被激活时候的类名，加上一个css样式，然后点击别的时候会自动去掉。 12345678910111213141516171819&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;Vue路由测试&lt;/h2&gt; &lt;!-- 导航区 --&gt; &lt;div class=&quot;navigate&quot;&gt; &lt;RouterLink to=&quot;/home&quot; active-class=&quot;active&quot;&gt;首页&lt;/RouterLink&gt; &lt;RouterLink to=&quot;/news&quot; active-class=&quot;active&quot;&gt;新闻&lt;/RouterLink&gt; &lt;RouterLink to=&quot;/about&quot; active-class=&quot;active&quot;&gt;关于&lt;/RouterLink&gt; &lt;/div&gt; &lt;!-- 展示区 --&gt; &lt;div class=&quot;main-content&quot;&gt; &lt;RouterView&gt;&lt;/RouterView&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt; import {RouterLink,RouterView} from &#39;vue-router&#39; &lt;/script&gt; 两个注意点· 路由组件通常存放在pages 或 views文件夹，一般组件通常存放在components文件夹。 路由组件：靠路由规则渲染出来的,比如以下这是三个，一般是放在pages 或 views文件夹里(视图)。 1234567891011121314routes:[ { path:&#39;/home&#39;, component:Home }, { path:&#39;/news&#39;, component:News }, { path:&#39;/about&#39;, component:About } ] 一般组件：自己动手写出来的组件例如：&lt;Demo/&gt; 通过点击导航，视觉效果上“消失” 了的路由组件，默认是被卸载掉的，需要的时候再去挂载。 components组合成为view，一个页面(page)由多个view组合(例如导航栏、显示区等)而成。 路由器工作模式· history模式 优点：URL更加美观，不带有#，更接近传统的网站URL。 缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有404错误。 history:createWebHistory() hash模式 优点：兼容性更好，因为不需要服务器端处理路径。 缺点：URL带有#不太美观，且在SEO优化方面相对较差。 history:createWebHashHistory() to的两种写法· 12345&lt;!-- 第一种：to的字符串写法 --&gt; &lt;router-link active-class=&quot;active&quot; to=&quot;/home&quot;&gt;主页&lt;/router-link&gt; &lt;!-- 第二种：to的对象写法 --&gt; &lt;router-link active-class=&quot;active&quot; :to=&quot;{path:&#39;/home&#39;}&quot;&gt;Home&lt;/router-link&gt; 命名路由· 作用：可以简化路由跳转及传参。 给路由规则命名： 1234567891011121314151617routes:[ { name:&#39;zhuye&#39;, path:&#39;/home&#39;, component:Home }, { name:&#39;xinwen&#39;, path:&#39;/news&#39;, component:News, }, { name:&#39;guanyu&#39;, path:&#39;/about&#39;, component:About } ] 跳转路由： 12345&lt;!--简化前：需要写完整的路径（to的字符串写法） --&gt; &lt;router-link to=&quot;/news/detail&quot;&gt;跳转&lt;/router-link&gt; &lt;!--简化后：直接通过名字跳转（to的对象写法配合name属性） --&gt; &lt;router-link :to=&quot;{name:&#39;guanyu&#39;}&quot;&gt;跳转&lt;/router-link&gt; 嵌套路由· 增加一个children，注意里面的path路径是不需要加/的。 123456789101112131415161718const router = createRouter({ history: createWebHistory(), routes:[ { ... }, { name:&#39;xinwen&#39;, path:&#39;/news&#39;, component:News, children:[ name:&#39;xinwenneirong&#39; path:&#39;detail&#39;, component:Detail ] } ] }) 在使用RouterLink跳转时，to的路径要写完整。 123&lt;Router-Link to=&quot;/news/detail&quot;&gt;xxxx&lt;/Router-Link&gt; &lt;!-- 或 --&gt; &lt;Router-Link :to=&quot;{path:&#39;/news/detail&#39;}&quot;&gt;xxxx&lt;/Router-Link&gt; 一般组件用大驼峰，参数等命名用小驼峰。 路由传参· 如果数据在父组件上，但是子组件需要展示，通过父组件向子组件传递参数方式有两种。 1.query参数· 前情提要：News.vue是父组件，Detail.vue是子组件，父组件通过v-for来渲染新闻标题。 12345&lt;ul&gt; &lt;li v-for=&quot;news in newsList&quot; :key=&quot;news.id&quot;&gt; &lt;RouterLink&gt;&lt;/RouterLink&gt; &lt;/li&gt; &lt;/ul&gt; 步骤一： 父组件News.vue 在to地址的同时传入参数，写法如下 1&lt;Router-Link to=&quot;/news/detail?a=1&amp;b=2&amp;c=3&quot;&gt;xxxx&lt;/Router-Link&gt; 此时传递了三个参数a,b,c，多个参数使用&amp;隔开，这传入的是死数据，而且只是一个字符串。 所以要写成模板字符串，模版字符串则是在双引号&quot;&quot;里加上两个撇号，模版字符串里面嵌入JS可以通过$&#123;&#125;来实现，并且要把to变成:to。 1&lt;RouterLink :to=&quot;`/news/detail?id=${news.id}&amp;title=${news.title}&amp;content=${news.content}`&quot;&gt; 上述写法，一大长串儿，显得很不美观有点冗余，所以我们可以美化一下代码。 1234567891011&lt;RouterLink :to=&quot;{ path:&#39;/news/detail&#39;, query:{ id:news.id, title:news.title, content:news.content } }&quot; &gt; &lt;/RouterLink&gt; 这样就看起来比较美观，毕竟要做一个格式化工程师，如果在路由中定义了name参数，那么path路径可以换成name名称，更方便。 步骤二： 子组件Detail.vue接收参数，需要引入useRouter，可以看出是一个hooks。 1import {useRoute} from &#39;vue-router&#39; 通过定义一个数据来接收useRouter 1let route = useRoute() 如果你不知道route里面包含了什么可以通过打印来查看，返回的里面包含了一个query参数，这个参数里面包含了父组件传过来的值。 引用 12345&lt;template&gt; &lt;div&gt;id={{route.query.id}}&lt;/div&gt; &lt;div&gt;title={{route.query.title}}&lt;/div&gt; &lt;div&gt;content={{route.query.content}}&lt;/div&gt; &lt;/template&gt; 如果解构赋值。 12let route = useRouter() let {query} = route 重点：如果从响应式数据中直接解构属性，那么这个属性就会就此失去响应式，如果不想失去响应式，那么可以使用toRefs就不会失去了。调用也更加方便即： 12345678910111213&lt;template&gt; &lt;div&gt;id={{query.id}}&lt;/div&gt; &lt;div&gt;title={{query.title}}&lt;/div&gt; &lt;div&gt;content={{query.content}}&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import {toRefs} from &#39;vue&#39; let route = useRouter() let {query} = toRefs(router) &lt;/script&gt; 2.params参数· 首先是要在路由中配置占位符，使用/:xxx来进行占位符，占位符所对应的名称要和传入的参数名称相对应，在后面加上?该参数可有可无。 12345678910111213141516171819const router = createRouter({ history: createWebHistory(), routes:[ { ... }, { name:&#39;xinwen&#39;, path:&#39;/news&#39;, component:News, children:[ name:&#39;xinwenneirong&#39; // 后面加上?表示该参数可以没有值 path:&#39;detail/:id/:title/:content?&#39;, component:Detail ] } ] }) 传递参数 这里的跳转只可以使用name参数，不可以使用path，如果是query的话两个都可以 12345678910111213141516 &lt;!-- 跳转并携带params参数（to的字符串写法） --&gt; &lt;RouterLink :to=&quot;`/news/detail/001/新闻001/内容001`&quot;&gt;{{news.title}}&lt;/RouterLink&gt; &lt;!-- 跳转并携带params参数（to的对象写法） --&gt; &lt;RouterLink :to=&quot;{ name:&#39;xinwen&#39;, //用name跳转 params:{ id:news.id, title:news.title, content:news.content } }&quot; &gt; {{news.title}} &lt;/RouterLink&gt; 接收参数： 1234import {useRoute} from &#39;vue-router&#39; const route = useRoute() // 打印params参数 console.log(route.params) 备注1：传递params参数时，若使用to的对象写法，必须使用name配置项，不能用path。 备注2：传递params参数时，需要提前在规则中占位。 路由的props配置· 简单点就是可以获取值的时候不那么麻烦，响应式数据只写&#123;&#123; xxx &#125;&#125;这种语法是最棒的，所以我们就要用这种方法。 props的功能可以这里么理解，当路由已经找到了并开始渲染&lt;Detail /&gt;组件时，如果我们开启了props。 那么我们使用params传递的三个参数就会进行转化为类似于组件传递值的方法，于是就变成了&lt;Detail id=?? title=?? content=?? /&gt;。 于是乎就特别简单了，这些props参数可以直接使用defineProps函数接收。 第一种props 第一种使用的是params来传递参数 123456789101112131415// router.ts { name:&#39;xinwen&#39;, path:&#39;/news&#39;, component:News, children:[ name:&#39;xinwenneirong&#39; // 后面加上?表示该参数可以没有值 path:&#39;detail/:id/:title/:content?&#39;, component:Detail, // 第一种写法：将路由收到的所有params参数座位props传给路由组件 props:true ] } 1234567891011// Detail.vue &lt;template&gt; &lt;div&gt;编号：{{ id }}&lt;/div&gt; &lt;div&gt;标题：{{ title }}&lt;/div&gt; &lt;div&gt;内容：{{ content }}&lt;/div&gt; &lt;/templat&gt; &lt;script setup lang=&quot;ts&quot; name=&quot;detail&quot;&gt; defineProps([&#39;id&#39;,&#39;title&#39;,&#39;content&#39;]) } &lt;/script&gt; 这就叫优雅的代码！！！（但是这个只能和params参数进行配合，如果是query就不行了），所以我们可以使用第二种props写法，函数写法。 第二种props 使用query传递参数 如果使用的是query来传值，那么只能用这种办法，当然params也同样适用，但是params可以直接使用第一种更加方便。 1234567891011121314151617// router.ts { name:&#39;xinwen&#39;, path:&#39;/news&#39;, component:News, children:[ name:&#39;xinwenneirong&#39; // 后面加上?表示该参数可以没有值 path:&#39;detail/:id/:title/:content?&#39;, component:Detail, // 第二种写法：函数写法可以自己决定将什么作为props给路由组件 props(route) { return route.query } ] } 1234567891011// Detail.vue &lt;template&gt; &lt;div&gt;编号：{{ id }}&lt;/div&gt; &lt;div&gt;标题：{{ title }}&lt;/div&gt; &lt;div&gt;内容：{{ content }}&lt;/div&gt; &lt;/templat&gt; &lt;script setup lang=&quot;ts&quot; name=&quot;detail&quot;&gt; defineProps([&#39;id&#39;,&#39;title&#39;,&#39;content&#39;]) } &lt;/script&gt; 常用的就这两种，第三种是对象写法，就是传递固定的值，几乎不用。 12345678910111213// router.ts ... children:[ name:&#39;xinwenneirong&#39; // 后面加上?表示该参数可以没有值 path:&#39;detail/:id/:title/:content?&#39;, component:Detail, props(route) { a:100, b:200, c:300 } ] 这些都是路由组件的传递方式，如果是一般组件(一般组件就是自己可以动手写在代码里的那么可以直接传递props，比如我们可以直接&lt;Deatil a=1 b=2 c=3/&gt;)。 路由的replace属性· 路由的每次跳转都会形成历史记录，可以在浏览器的左上角的左右箭头进行前进后退，这是因为路由跳转默认是push模式，如果不想这样，那么可以改成replace模式，即不能前进也不能后退。 要改为replace，只需要在RouterLink标签中，加入replace属性即可。 123&lt;RouterLink replace to=&quot;/home&quot;&gt;首页&lt;/RouterLink&gt; &lt;RouterLink replace to=&quot;/news&quot;&gt;新闻&lt;/RouterLink&gt; &lt;RouterLink replace to=&quot;/about&quot;&gt;关于&lt;/RouterLink&gt; 如果想看到某一个具体的就不让他回去的话，那么就可以单独加上replace。 编程式导航(重要)· 我们之前的跳转，全部使用了&lt;RouterLink /&gt;标签进行实现，那么&lt;RouterLink /&gt;标签在最后会被转化为&lt;a/&gt;标签，这就导致了，如果全部都使用，那么就会出现一堆&lt;a/&gt;元素。 所谓编程式导航，其实就是脱离&lt;RouterLink /&gt;来实现路由跳转。 打开页面3秒后跳转到新闻页面。 123456789101112import {onMounted} from &#39;vue&#39; // 注意是router 后面加了r import {useRouter} from &#39;vue-router&#39; // 拿到router，相当于掌握了整个路由 const router = useRouter() onMounted(()=&gt;{ setTimeout(()=&gt;{ router.push(&quot;/news&quot;) },3000) }) 编程式路由导航的使用频率要远大于RouterLink式。 router.push()和to的语法是一样的，都有两个模式字符串和对象，而且语法一模一样，直接拿过来用就行，但是参数需要传递过来。 通过按钮点击来查看新内容，那么就可以直接把之前的to来拿用。 1234567891011121314151617181920212223242526272829303132// ts会告诉你news参数有一个隐式any类型，简单方式就是后面直接加:any，不然就是使用interface来限制一下。 function showNewsDeatil(news:any){ router.push({ name:&quot;xiang&quot;, query:{ id:news.id, title:news.title, content:news.conten } }) } // or // 限制有限制的好处，可以让数据更严谨 interface NewInter { id:string, title:string, content:string } function showNewsDeatil(news:NewInter){ router.push({ name:&quot;xiang&quot;, query:{ id:news.id, title:news.title, content:news.conten } }) } 当然了，如果不想使用push留下痕迹,可以直接router.replace()进行使用。 路由重定向· 作用：将特定的路径，重新定向到已有路由。 我们想一打开页面就直接显示主页等想一开始就显示的内容，顺序不分先后。 12345678910111213// router.ts { name:&#39;xinwen&#39;, path:&#39;/news&#39;, component:News }, { ... }, { path:&#39;/&#39;, redirect:&#39;/home&#39; } 连续解构赋值+重命名写法 1let {data:{content:title}} ↑返回的数据名叫data，需要从data中拿到content值，又把content名改为title Pinia· 官网：Pinia | The intuitive store for Vue.js (vuejs.org) 官方描述为：符合直觉的Vue.js状态管理哭，说白了就是用着很舒服，没有vuex那么臃肿。 集中式状态管理也叫集中式数据管理，常见的有：react的redux，vue2的vuex，vue3的pinia。 hooks的作用只是把代码集中在一起，而pinia是各个组件之间共享数据。 搭建Pinia环境· 1npm i pinia 引入Pinia 123456789101112131415161718// src/main.ts // 导入Vue import { createApp } from &#39;vue&#39; // 导入App组件 import App from &#39;./App.vue&#39; // 1.引入pinia import {createPinia} from &#39;pinia&#39; // 2.创建pinia const pinia = createPinia() // 3.安装pinia app.use(pinia) // 创建Vue应用实例 createApp(App).mount(&#39;#app&#39;) 存储数据+读取数据· 首先src目录下必须有store文件夹，pinia具体就体现在这里。 里面的文件命名一般是和组件相对应的，比如我们有一个count.vue组件，那我们可以创建一个store/count.ts文件，可以把这个文件看做是一个小仓库。 Pinia官方鼓励我们使用类似hooks的方式命名，所以我们可以命名为useCountStore，引入defineStore，它的第一个参数建议和组件名相同count，然后在第二个参数就是开始配置。 state要求要写成一个函数，并且要return一个对象，可以是字符串也可以是对象，我们这里把sum进行共享，并默认值设为6。 1234567891011import {defineStore} from &#39;pinia&#39; export default const useCountStore = defineStore(&#39;count&#39;,{ // 真正存储数据的地方 state({ return { sum:6 } }) }) count.vue中不需要定义sum，我们直接引入提到的小仓库，只要看到引入的目录中带store，那就是引用了pinia。 这里有值得注意的一点，如果是自己动手写定义的ref属性，那么在使用的时候是必要.value的。 但是如果是在reactive里面定义的ref，会自动拆包，也就是不需要.value了， 12345678910111213// 引入countStore import { useCountStore } from &#39;@/store/count&#39; // 使用useCountStore，得到一个专门保存count相关的store conts countStore = useConutStore() // 以下这两种方式都可以拿到state中的数据 console.log(&#39;输出&#39;,countStore.sum) // 输出 6 console.log(&#39;输出&#39;,countStore.$state.sum) // 输出 6 我们现在已经拿到了sum的值，就可以直接正常使用了，并且数据也是共享的。 1&lt;h2&gt;求和结果：{{ countStore.sum }}&lt;/h2&gt; 修改数据三种方式· Pinia是支持直接把数据拿过来就修改的，符合直觉。 第一种修改方式，直接修改，比如我们要修改sum。 123function add() { countStore.sum += 1 } 对，就是这么简单暴力，可以直接拿来用，这个在vuex中是不可以的。 第二种修改方式，使用$patch函数修改。 $patch是一个实用函数,用于直接修改状态对象(state)的一个或多个属性，属于批量变更，它的好处是执行一次就可以修改多个参数。 1234567function modify() { countStore.$patch({ sum:10, name:&#39;张三&#39;, address:&#39;北京&#39; }) } 如果是多个值需要同时发生变化，就推荐使用$patch，可以达到占用最少的资源。 第三种修改方式 actions 借助actions实现（actions中可以编写一些业务逻辑）。 12345678910111213141516171819202122232425262728import { defineStore } from &#39;pinia&#39; export const useCountStore = defineStore(&#39;count&#39;, { //actions里面放的是一个一个的方法，用于响应组件中的&quot;动作&quot;(加减都是动作) actions: { //加操作 // 这里设定一个number类型的参数来接收传过来的数值 increment(value:number) { // 操作state里面的数据可以直接使用this // this就是当前的store，所以当前这个store里面的东西全都有 // 限制加到10不能加了 if (this.sum &lt; 10) { //操作countStore中的sum this.sum += value } }, // 减操作 decrement(value:number){ if(this.sum &gt; 1){ this.sum -= value } } }, /*************/ }) 组件中调用actions 12345// 使用countStore const countStore = useCountStore() // 调用对应action，加并且传入加的数值 countStore.incrementOdd(n.value) 这里的actions感觉看起来好像就是正常的操作，还不如第一种来的实在，因为actions可以完成的在第一种都可以完成，但是actions中的业务逻辑，是可以进行复用的，所以也很有意义。 storeToRefs· 这里想让你在读数据的时候更加优雅一些。 因为我们以上的操作在读取响应式数据的时候都是countStore.sum等等前面都带一个countStore，一点儿也不优雅，所以我们可以让他更优雅一些。 可能会想到，直接解构数据就好咯，但是这样不行，这样会导致数据就此丢失响应式，那么又想一下，引入一个toRefs来包裹一下不就好了，确实可以，而且也可以正常运营，但是代价很大。 因为他会把你的store中的所有数据，包括函数什么的，全部都变成ref响应式数据，我们其实只需要数据罢了，所以不要用toRefs，这样不好。 但是要解决这个问题也很简单，Pinia也考虑到了这个问题，所以提供了storeToRefs，大白话直说：这个只会把store中的数据变成响应式数据给你。 1234import {storeToRefs} from &#39;pinia&#39; const {sum,name,address} = storeToRefs(useCountStore()) geeters· geeters和state、actions都是 兄弟，所以他们都是同级，geeters里面是写函数的，而且必须返回一个值，就相当于计算属性。 在geeters里面定义的函数，都有一个参数叫state，所以在getters中可以直接通过这个参数来调用state中的数据，也可以直接使用this，不用this可以直接写成箭头函数。 12345678910111213141516171819202122232425262728293031323334// 引入defineStore用于创建store import {defineStore} from &#39;pinia&#39; // 定义并暴露一个store export const useCountStore = defineStore(&#39;count&#39;,{ // 动作 actions:{ /************/ }, // 状态 state(){ return { sum:1, school:&#39;nihao&#39; } }, // 计算 getters:{ // 第一种写法 bigAdd(state){ return state.sum + 10 }, // 第二种写法 箭头函数形式 bigSum:(state):number =&gt; state.sum * 10, // 将state中的school变成默认大写 // 后面的:string 就是声明是字符串类型，这是ts的检查不然就默认any upperSchool():string{ return this.school.toUpperCase() } } }) 这里的计算属性，同样是和响应式数据一样，可以拿来直接使用，并且也是可以直接解构出来进行使用。 $subscribe 订阅的使用· 每个store中都有$subscribe函数，类似于watch监视。可以直接调用，并且要传入一个函数，如果你不需要用this那么你可以使用箭头函数，官方文档使用的是箭头函数。 那么$subscribe的主要作用是，当store中的数据发生了变化以后，就会调用。 它收到两个参数，mutate修改前的数据， state修改后的数据，state使用频率是最多的。 我们可以把state中的修改后的数据存入浏览器中 123countStore.$subscribe((mutate,state)=&gt;{ localStorage.setItem(&quot;countList&quot;,JSON.stringify(state.countList)) }) JSON.stringify：用于把内容转化为字符串。JSON.parse：用于把字符串转回来。 此时我们的数据可以这样定义 123456789101112131415// store/count.ts import {defineStore} from &#39;pinia&#39; export default const useCountStore = defineStore(&#39;count&#39;,{ // 真正存储数据的地方 state({ return { // as string进行断言，保证严谨性 // 这里后面的 或 ||[] 是为了避免第一次运行local storage中没有数据，然后导致错误，所以要加上。 countList:JSON.parse(localStorage.getItem(&#39;countList&#39;) as string) || [] } }) }) store的组合式写法· 我们之前写的，属于是选项式写法，比如actions和state都是写在了一个对象里，我们把defineStore的第二个参数写成箭头函数，就可以使用组合式store了，但是记住箭头函数中不可以使用this。 组合式store例子，你就把他当做一个setup函数就可以了。 1234567891011121314151617181920212223242526272829// store/count.ts import {defineStore} from &#39;pinia&#39; import axios from &#39;axios&#39; import {nanoid} from &#39;nanoid&#39; // 直接引入 import {reactive} from &#39;vue&#39; // 这里第二个参数使用箭头函数形式 export default const useCountStore = defineStore(&#39;count&#39;,()=&gt;{ // countList就相当于state，可以定义多个。 const countList = reactive(JSON.parse(localStorage.getItem(&#39;countList&#39;) as string) || []) // getCount 相当于 actions async function getCount(){ // 发请求，这个写法是连续解构赋值+重命名 let {date:{content:title}} = await axios.get(&#39;api&#39;) // 把请求回来的字符串包装成一个对象 let obj = {id:nanoid(),title} // 放入数组中 countList.unshift(obj) } // 不要忘记return返回值。 return {countList,getCount} }) 组件通信· 组件通信就是组件之间互相传递数据，这个玩的6很重要。 props· props是使用频率最高的一种通信方式，常用与 ：父 ↔ 子。 若 父传子：属性值是非函数，就是字符串、数字之类的。 若 子传父：属性值是函数，父先给子函数，子在调用传值。 父组件： 1234567891011121314151617181920212223242526272829 &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h3&gt;父组件，&lt;/h3&gt; &lt;h4&gt;我的车：{{ car }}&lt;/h4&gt; &lt;h4&gt;儿子给的玩具：{{ toy }}&lt;/h4&gt; // 在子组件中使用 :传递名=&quot;传递数据&quot;，这些名字都是可以任意取的没有限制，但是最好还是容易理解一些 // &lt;Child :car=&quot;car&quot; :sendToy=&quot;getToy&quot;/&gt; &lt;/div&gt; &lt;/template&gt; ​ &lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt; import Child from &#39;./Child.vue&#39; import { ref } from &quot;vue&quot;; // 数据 const car = ref(&#39;奔驰&#39;) // 定义一个用来接收子组件传过来的数据 const toy = ref() // 方法 // 定义一个方法来接收子组件传过来的数据 function getToy(value:string){ // value的值就是子传过来的值，然后接收就行了 toy.value = value } &lt;/script&gt; 子组件 123456789101112131415161718 &lt;template&gt; &lt;div class=&quot;child&quot;&gt; &lt;h3&gt;子组件&lt;/h3&gt; &lt;h4&gt;我的玩具：{{ toy }}&lt;/h4&gt; &lt;h4&gt;父给我的车：{{ car }}&lt;/h4&gt; // 这里因为defineProps已经拿到了getToy所以可以直接使用，然后把玩具给传入进去，父组件那边正好可以接收。 &lt;button @click=&quot;getToy(toy)&quot;&gt;玩具给父亲&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; ​ &lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt; import { ref } from &quot;vue&quot;; const toy = ref(&#39;奥特曼&#39;) // 声明接收的数据使用defineProps 无需引入，接收完了之后可以直接拿来使用 defineProps([&#39;car&#39;,&#39;getToy&#39;]) &lt;/script&gt; 父传子，比较容易理解，直接就可以传到子组件中去。 但子传父，就需要父亲先给子传入一个函数，子收到这个函数，在调用这个函数的时候以传参的形式把值传递过去。 自定义事件 custom_event· 当你定义函数的时候，有一个默认参数，这个参数就是事件对象，里边包含了很多事件，比如鼠标移动之类的坐标。 概述：自定义事件常用于：子 传 父。 注意区分好：原生事件、自定义事件。 在定义@click点击事件的时候，传入$event占位符，即表示这是一个事件对象，那么test函数的c参数，就是一个事件对象了。 123456789 //template &lt;button @click=&quot;test(5,6,$event)&quot;&gt;点击&lt;/button&gt; // ts function test(a:number,b:number,c:Event){ console.log(&#39;print&#39;,a,b,c) } 原生事件： 事件名是特定的（click、mosueenter等等） 事件对象$event: 是包含事件相关信息的对象（pageX、pageY、target、keyCode） 自定义事件： 事件名是任意名称 事件对象$event: 是调用emit时所提供的数据，可以是任意类型！！！ 父组件在调用子组件的时候，通过@xxx = &quot;xxx&quot;来定义一个自定义事件 12345&lt;!--在父组件中，给子组件Child绑定自定义事件：--&gt; &lt;Child @send-toy=&quot;toy = $event&quot;/&gt; ​ &lt;!--注意区分原生事件与自定义事件中的$event--&gt; &lt;button @click=&quot;toy = $event&quot;&gt;测试&lt;/button&gt; 子组件，需要调用defineEmits，并且传入一个数组来进行接收 123456 // 声明事件 defineEmits([&#39;send-toy&#39;]) //子组件中，触发事件： this.$emit(&#39;send-toy&#39;, 具体数据) 子组件emit('haha',666)中的这个666在处罚的时候会以参数的形式被传递到父组件中的xyz函数的value参数中去，同理666可以替换为ref定义的toy数据。 另外自定义组件的命名推荐使用肉串命名kebab-case，比如my-event mitt· 可以实现任意组件通信，有种一拍即合的感觉，学到了就会了，mitt就像是组件中的中间人。 首先就是要安装mitt 1npm i mitt 一般是放在utils或者tools文件夹中写一个emitter.ts文件，然后在项目文件中需要的时候进行引用，和自定义事件挺像的。 123456789101112131415161718192021222324252627282930// 引入mitt import mitt from &#39;miit&#39; // 调用miit得到emitter，emitter可以绑定以及触发事件。 const emitter = mitt() // 绑定事件 emitter.on(&#39;abc&#39;,(value)=&gt;{ console.log(&#39;abc事件被触发&#39;,value) }) emitter.on(&#39;xyz&#39;,(value)=&gt;{ console.log(&#39;xyz事件被触发&#39;,value) }) setInterval(() =&gt; { // 触发事件 emitter.emit(&#39;abc&#39;,666) emitter.emit(&#39;xyz&#39;,777) }, 1000); setTimeout(() =&gt; { // 清理事件 全全部绑定的都清理掉了 emitter.all.clear() }, 3000); // 暴露emitter export default emitter mitt 提供了四个主要方法: on(event, handler) 绑定事件 off(event, handler) 解绑事件 emit(event, …args) 触发事件 all.clear() 清除全部事件 接收数据的组件中：绑定事件、同时在销毁前解绑事件： 1234567891011121314 import emitter from &quot;@/utils/emitter&quot;; import { onUnmounted } from &quot;vue&quot;; ​ // 绑定事件 emitter.on(&#39;send-toy&#39;,(value)=&gt;{ console.log(&#39;send-toy事件被触发&#39;,value) }) ​ // 在组件卸载时解绑send-toy事件，可以释放内存，很必要。 onUnmounted(()=&gt;{ // 解绑事件 emitter.off(&#39;send-toy&#39;) }) 提供数据的组件，在合适的时候触发事件 123456import emitter from &quot;@/utils/emitter&quot;; ​ function sendToy(){ // 触发事件 emitter.emit(&#39;send-toy&#39;,toy.value) } 注意这个重要的内置关系，总线依赖着这个内置关系 v-model通信传值· ui组件库的底层，大量使用v-model进行通信，这里是v-model的底层原理。 v-model是双向绑定，它的底层原理是一个动态的value值:value='xxx'，加上@input='xxx = $event.target.value' $event:事件对象，target，发生事件的本体，value就拿到了他的值。 v-model用在html标签上 1234567// 两个写法是等价的 // v-model写法 &lt;input type=&#39;text&#39; v-model=&#39;username&#39;&gt; // 原生写法 &lt;input type=&#39;text&#39; :value=&quot;username&quot; @input=&quot;username = $event.target.value&quot;&gt; v-model用在组件标签上 我们正常使用的是上面的写法，但是最终会被转化成为下面的写法。 组件接收使用 12&lt;input type=&#39;text&#39; :value=&quot;modelValue&quot; @input=&quot;emit(&#39;update:modelValue = $event.target.value&#39;)&quot; &gt; 12defineProps([&#39;modelValue&#39;]) const emit = defineEmits([update:modelValue]) $event就是dom事件对象，一般在组件标签上使用 $event，而且HTML原生标签中使用 $event.target用来获取DOM对象。 $event到底是啥？啥时候能.target？ 对于原生事件，$event就是事件对象 =&gt; 能.target 对于自定义事件，$event就是触发事件时，所传递的数据 不能.target v-model既能父传子也能子传父。 v-model多个写法· 即可以在一个标签上可以写多个v-model，写法如下，即可以传入多个值。 1&lt;el-input v-model:mingcheng=&#39;username&#39; v-model:mima=&#39;password&#39; /&gt; $attrs· 概述：$attrs用于实现当前组件的父组件，向当前组件的子组件通信（祖→孙）。可以理解父组件通过子组件来传递给孙组件。 具体说明：$attrs是一个对象，包含所有父组件传入的标签属性。 注意：$attrs会自动排除props中声明的属性(可以认为声明过的 props 被子组件自己“消费”了) 简单来说，就是你传了a、b、c三个值，但是只有a被props接收了，那么剩下的b、c就都存在attrs里面。 可以直接在模板上通过&#123;&#123; $attrs &#125;&#125;来查看 单项传递数据 父组件 v-bind=&quot;&#123;x:100,y:200&#125;&quot; == :x=100 :y=200 这两个写法是一样的，如果子组件不进行使用这些数据，那么可以直接在孙组件标签上添加v-bind=&quot;$attrs&quot;，来直接传递给孙组件。 然后孙组件就可以通过defineProps来直接接收父组件的东西了。 如果要孙组件传递给父组件，那么在传入的时候加入一个回调函数，当然这个函数也会被包含在$attrs中，孙组件直接接收进行使用就可以了。 123456789// 父组件 let a = ref(1) updateA(value:number){ a.value += value } // updateA=&quot;updateA&quot; 在子组件标签中传入 // 孙组件接收后调用，加入给函数传入一个数字6，那么在子组件调用一次，那么a这个数据就会+6，无论是在父组件还是子组件是。 $refs 和 $parent· 概述： $refs用于 ：父→子。 $parent用于：子→父。 原理如下： 属性 说明 $refs 值为对象，包含所有被ref属性标识的DOM元素或组件实例。 $parent 值为对象，当前组件的父组件实例对象。 通过父组件来改子组件中的内容，可以在父组件中给子组件标签打上ref='xxx'记号，然后在子组件通过宏函数把数据导出，导出后此时的ref中的xxx，就可以拿到子组件导出来的数据了，然后就可以进行操作了。 12// 把数据交给外部 defineExpose({数据铭,函数名}) $refs可以直接调用，里面包含了所有通过ref打上标签的子组件。 假如父组件中引入了两个子组件，那么通过一个普通的按钮来创建一个点击方法，这个方法里面的参数传入$refs，然后在就可以打印出来这两个子组件的实例对象 两个子组件中有相同的一个数据，想让他们每次点击都+2个。 123&lt;button @clikc=&quot;getAllChild($refs)&quot; /&gt; &lt;Child1 ref=&quot;c1&quot;)/&gt; &lt;Child2 ref(&quot;c2&quot;)/&gt; 12345678 // 按钮中单击事件的函数，这个refs的确是一个对象，然后里面的key我可以确定是一个字符串，里面存的东西我不确定所以用any，但是可以any一把梭哈 function getAllChild(refs:{key:string:any}){ // 遍历出来每个组件中的相同那个数据,然后+2 for (key in refs) { refs[key].number += 2 } } 反过来$parent就是拿到父亲的数据，用法都一样，当然了父组件也要加上defineExpose(&#123;数据名&#125;)进行向外部提供数据。 provide、inject 很好用· 概述：实现祖孙组件直接通信，不打扰子组件。 具体使用： 在祖先组件中通过provide配置向后代组件提供数据 在后代组件中通过inject配置来声明接收数据 这两个都不带响应式。 具体编码： 【第一步】父组件中，使用provide提供数据。 引入provide函数，然后进行调用。 123456789101112131415161718192021222324252627282930 &lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h3&gt;父组件&lt;/h3&gt; &lt;h4&gt;资产：{{ money }}&lt;/h4&gt; &lt;h4&gt;汽车：{{ car }}&lt;/h4&gt; &lt;button @click=&quot;money += 1&quot;&gt;资产+1&lt;/button&gt; &lt;button @click=&quot;car.price += 1&quot;&gt;汽车价格+1&lt;/button&gt; &lt;Child/&gt; &lt;/div&gt; &lt;/template&gt; ​ &lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt; import Child from &#39;./Child.vue&#39; import { ref,reactive,provide } from &quot;vue&quot;; // 数据 let money = ref(100) let car = reactive({ brand:&#39;奔驰&#39;, price:100 }) // 用于更新money的方法 function updateMoney(value:number){ money.value += value } // 向后代提供数据 // 数据 方法 对象 都提供出去，注意响应式数据不需要.value，如果加上那么就不会是响应式数据了。 provide(&#39;moneyContext&#39;,{money,updateMoney}) provide(&#39;car&#39;,car) &lt;/script&gt; 函数用于孙传父 注意：子组件中不用编写任何东西，是不受到任何打扰的 【第二步】孙组件中使用inject配置项接受数据。 inject第一个参数是接收的名称，和父组件提供的名称一样；第二个参数是默认值，即如果没有接收到就是用默认的替代； 12345678910111213141516&lt;template&gt; &lt;div class=&quot;grand-child&quot;&gt; &lt;h3&gt;我是孙组件&lt;/h3&gt; &lt;h4&gt;资产：{{ money }}&lt;/h4&gt; &lt;h4&gt;汽车：{{ car }}&lt;/h4&gt; &lt;button @click=&quot;updateMoney(6)&quot;&gt;点我&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; ​ &lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt; import { inject } from &#39;vue&#39;; // 注入数据 可以写多个 并且可以直接解构 let {money,updateMoney} = inject(&#39;moneyContext&#39;,{money:0,updateMoney:(x:number)=&gt;{}}) // 数据名 默认值 let car = inject(&#39;car&#39;,{brand:&#39;奔驰&#39;,price:100}) &lt;/script&gt; slot 插槽· 一般是同时呈现多个组件，但是组件里面的内容只有些许的不一样，这样就不用写多个组件，只需要用一个组件来完成。 默认插槽· 1234567891011121314父组件中：传递一个列表过去 &lt;Category title=&quot;今日热门游戏&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;{{ g.name }}&lt;/li&gt; &lt;/ul&gt; &lt;/Category&gt; 子组件中： &lt;template&gt; &lt;div class=&quot;item&quot;&gt; &lt;h3&gt;{{ title }}&lt;/h3&gt; &lt;!-- 默认插槽 --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 在父组件中使用子组件，并且使用了双标签，可以在双标签的中间夹一些html标签，并且这些标签会在子组件中的&lt;slot&gt;&lt;/slot&gt;标签的位置进行渲染。 假如你什么数据也没传过来，可以通过&lt;slot&gt;默认内容&lt;/slot&gt;这样当你没夹杂标签就会显示默认的内容。 这样当我们实现最上面图片的需求时，我们只需要写三个子组件标签，并夹杂着不同的内容带过去，这些不同的内容都被放在了子组件中的&lt;slot&gt;&lt;/slot&gt;标签中。 注意slot标签做的是呈现，比如样式什么的还是在父组件中进行修改比较好，并且只需要写一个slot标签就行，写多个就会呈现多次。 简单理解：你在子组件中挖了一个坑，这个坑等着你来填土；这三个东西都可以填进来。 具名插槽· 就是给坑取名字，然后让对应的名字到对应的坑中。 子组件的slot使用name来取一个名字，默认名为：default 1234&lt;template&gt; &lt;slot name=&#39;s1&#39;&gt;&lt;/slot&gt; &lt;slot name=&#39;s&#39;&gt;&lt;/slot&gt; &lt;/template&gt; 父组件把标签都放到template中，然后通过v-slot:x来命名，也可以通过#x来命名，可以写多个；注意template是写在组件标签内的。 12345678910111213&lt;template&gt; &lt;Chirld&gt; &lt;template v-slot:s&gt; &lt;ul&gt; &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;{{ g.name }}&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; // 这里使用 &#39;#&#39; = &#39;v-slot&#39; &lt;template #s1&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;/template&gt; &lt;/Chirld&gt; &lt;/template&gt; 在子组件中通过名字来引用，在子组件中s1名称对应的标题会在上方，而s对应的会在下方。样式之类的只需要在父组件中进行设置就可以了。 作用域插槽· 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（新闻数据在News组件中，但使用数据所遍历出来的结构由App组件决定） 1234567891011121314151617181920212223242526父组件中： &lt;Game v-slot=&quot;params&quot;&gt; &lt;!-- &lt;Game v-slot:default=&quot;params&quot;&gt; --&gt; &lt;!-- &lt;Game #default=&quot;params&quot;&gt; --&gt; &lt;ul&gt; &lt;li v-for=&quot;g in params.games&quot; :key=&quot;g.id&quot;&gt;{{ g.name }}&lt;/li&gt; &lt;/ul&gt; &lt;/Game&gt; 子组件中： &lt;template&gt; &lt;div class=&quot;category&quot;&gt; &lt;h2&gt;今日游戏榜单&lt;/h2&gt; &lt;slot :games=&quot;games&quot; a=&quot;哈哈&quot; x=&quot;hello&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang=&quot;ts&quot; name=&quot;Category&quot;&gt; import {reactive} from &#39;vue&#39; let games = reactive([ {id:&#39;asgdytsa01&#39;,name:&#39;英雄联盟&#39;}, {id:&#39;asgdytsa02&#39;,name:&#39;王者荣耀&#39;}, {id:&#39;asgdytsa03&#39;,name:&#39;红色警戒&#39;}, {id:&#39;asgdytsa04&#39;,name:&#39;斗罗大陆&#39;} ]) &lt;/script&gt; 在父组件中的子组件标签中v-slot=&quot;params&quot;表明params作为一个变量名接收了子组件slot标签&lt;slot :games=&quot;games&quot; a=&quot;哈哈&quot; x=&quot;hello&quot;&gt;&lt;/slot&gt;里面传递过来的games、a、x三个参数、即为所有参数。 对于命名还是和之前一样，比如：v-slot:s=&quot;params&quot;，子组件：name='s'。 数据的维护什么都在子组件中，但是根据这些数据所生成的结构是父组件决定的。 简单理解：压岁钱在孩子那，但是根据压岁钱买的东西，却由父亲来决定。 其他API· shallowRef 与 shallowReactive· 需要从vue中引用 shallowRef 作用：创建一个响应式数据，但只对顶层属性进行响应式处理。 用法： 1let myVar = shallowRef(initialValue); 特点：只跟踪引用值的变化，不关心值内部的属性变化。 简单理解：我可以对person.value进行修改值，并且有响应式处理，但是我对person.value.name就没有响应式处理了，就是只可以.一次。 如果你关注的是数据的整体修改，那么就使用shallowRef。 shallowReactive 同理。 作用：创建一个浅层响应式对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的。 通过使用 shallowRef() 和 shallowReactive() 来绕开深度响应。浅层式 API 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理，避免了对每一个内部属性做响应式所带来的性能成本，这使得属性的访问变得更快，可提升性能。 readonly 与 shallowReadonly· 都是需要通过vue来引用的，然后直接使用。 readonly 作用：用于创建一个对象的深只读副本，限制所有层次。 用法： 12const original = reactive({ ... }); const readOnlyCopy = readonly(original); 当你在修改original的时候，那么readOnlyCopy的值也会跟着响应式进行变化，是有关联关系的，但是如果直接修改readOnlyCopy则无法修改，会提示警告. 相当于复制了一份只能用来使用但是不能修改的数据。 特点： 对象的所有嵌套属性都将变为只读，并且readonly的参数必须是响应式数据(ref,reactive)。 任何尝试修改这个对象的操作都会被阻止（在开发模式下，还会在控制台中发出警告）。 应用场景： 创建不可变的状态快照。 保护全局状态或配置不被修改。 shallowReadonly 与 readonly 类似，但只作用于对象的顶层属性，就是只限制第一层，更深层次的就不限制了。 12const original = reactive({ ... }); const shallowReadOnlyCopy = shallowReadonly(original); toRaw 与 markRaw· 需要从vue中引用。 toRaw 函数用于获取由 ref、reactive、readonly 等创建的响应式对象的原始未代理的对象。当你需要访问到对象的原始数据，而不是其响应式代理时，就可以使用 toRaw； toRaw 返回的对象不再是响应式的，不会触发视图更新。 语法：const raw = toRaw(proxy) 官网描述：这是一个可以用于临时读取而不引起代理访问/跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。 何时使用？ —— 在需要将响应式对象传递给非 Vue 的库或外部系统时，使用 toRaw 可以确保它们收到的是普通对象 1234567import { reactive,toRaw,markRaw,isReactive } from &quot;vue&quot;; /* toRaw */ // 响应式对象 let person = reactive({name:&#39;tony&#39;,age:18}) // 原始对象 let rawPerson = toRaw(person) markRaw 作用：标记一个对象，使其永远不会变成响应式的。 例如使用mockjs时，为了防止误把mockjs变为响应式对象，可以使用 markRaw 去标记mockjs 123456789/* markRaw */ let citys = markRaw([ {id:&#39;asdda01&#39;,name:&#39;北京&#39;}, {id:&#39;asdda02&#39;,name:&#39;上海&#39;}, {id:&#39;asdda03&#39;,name:&#39;天津&#39;}, {id:&#39;asdda04&#39;,name:&#39;重庆&#39;} ]) // 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了,citys2会没有作用。 let citys2 = reactive(citys) customRef· 需要从vue中引用。 自定义Ref作用：创建一个自定义的ref，并对其依赖项跟踪和更新触发进行逻辑控制。 普通的ref定义的数据，只要数据一变化，页面立马就更新，假如想要间隔一秒变化，那就办不到。 customRef实现修改数据一秒后页面变化： 12345678910111213141516171819202122232425262728293031import {customRef} from &#39;vue&#39; // 定义一个默认值 let initValue = &#39;你好&#39; // 定义一个时间 let timer:number // 使用Vue提供的customRef定义响应式数据 // 箭头函数要接收从底层传过来的两个参数,track(跟踪)、trigger(触发) let msg = customRef((track,trigger)=&gt;{ return{ // msg被读取调用get get(){ track() // 告诉Vue数据msg很重要，你要对msg进行持续关注，一旦msg变化就要去更新。 // 要有返回值 return initValue }, // msg被修改调用set;value参数是修改后的最新值 set(value){ // 每次执行都清除一下 clearTimeout(timer) // 定时器 time = setTimeout(()=&gt;{ initValue = value trigger() // 通知Vue，数据msg变化了 },1000) } } }) 读数据之前要调用track，改数据改完了之后要调用trigger，必须同时存在，这两个都加上才会实现响应式效果，可以理解为在自己实现ref。 一般会把自定义ref封装成hooks。 巩固一下hooks：一般以useXxx命名比如useMsgRef.ts，然后把所有代码都给拿过来，hooks是一个函数，所以要包裹在函数里. 1234567891011121314151617181920212223242526272829303132333435// useMsgRef.ts import {customRef} from &#39;vue&#39; export default function(initValue:string,delay:number) { // 定义一个时间 let timer:number // 使用Vue提供的customRef定义响应式数据 // 箭头函数要接收从底层传过来的两个参数,track(跟踪)、trigger(触发) let msg = customRef((track,trigger)=&gt;{ return{ // msg被读取调用get get(){ track() // 告诉Vue数据msg很重要，你要对msg进行持续关注，一旦msg变化就要去更新。 // 要有返回值 return initValue }, // msg被修改调用set;value参数是修改后的最新值 set(value){ // 每次执行都清除一下 clearTimeout(timer) // 定时器 time = setTimeout(()=&gt;{ initValue = value trigger() // 通知Vue，数据msg变化了 },delay) } } }) // hooks最后要有返回值 return {msg} } 此时就可以在代码中进行引用useMsgRef 123456import {useMsgRef} from &#39;./useMsgRef&#39; // 普通ref let msg = ref(&#39;你好&#39;) // 自定义ref，可以增加自己的逻辑，注意解构 let {msg{} = useMsgRef(&#39;你好&#39;,2000) 总结：所谓customRef(自定义ref)就是在原来ref的基础上，加上一些自己的逻辑，这个主要聊的地方就是track(跟踪)和trigger(触发)。 Vue3新组件·","categories":[{"name":"前端","slug":"前端","permalink":"https://sawr.gitee.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://sawr.gitee.io/tags/TypeScript/"},{"name":"Vue","slug":"Vue","permalink":"https://sawr.gitee.io/tags/Vue/"}]},{"title":"读万卷书不如行万里路 我的骑行之旅","slug":"life/bicycle","date":"2024-02-13T16:00:00.000Z","updated":"2024-04-10T09:27:32.044Z","comments":true,"path":"2024/02/14/life/bicycle/","link":"","permalink":"https://sawr.gitee.io/2024/02/14/life/bicycle/","excerpt":"","text":"事情还要从23年6️月开始说起，我有两把木吉他，本来是准备卖了一把木的来买一把电的，但是由于种种原因，就没有很快的卖出去，直到23年的9月20号，女朋友背单词的封面是bicycle，封面那个自行车我觉得很帅，加上我本来也有想要买一辆自行车进行锻炼以及远行的心，就也想安排一辆，于是本来的电吉他，就变成了现在的自行车，于是就有了这个骑行之旅。 小白选车· 从萌生想法到选车，就是一瞬间的事儿，在那时候，我对自行车的理解还停留在小时候我妈给我买了一辆金泰美的自行车用来上下学用，然后就去淘宝上简单搜索了一下自行车，看的时候发现，这永久、凤凰等等这些牌子，感觉很牛啊，介绍里各种高端大气上档次，但是价格呢，六七百块，直觉告诉我，六七百块绝对买不了一辆很好的自行车，但是又不知道买什么自行车，我女友也在帮我搜各种牌子，但还是弄不懂，那时候就连拉屎也在选自行车。 后来在视频平台看了很多自行车的讲解视频，最简单的就是自行车目前分为两个阵营，山地车以及公路车，再简单了解一下就是山地车适合越野以及复杂的路面情况；公路车适合在平地骑行，公路车的速度要比山地车快不少，这一下子让我很懵，现在自行车都这么复杂了吗？ 现在已经是2023年的11月8日了。我还没有选好车，不是我纠结，而是吉他还没卖出去，当然这都是小问题，主要是还没选好，本来想买二手的捷安特ATX系列，但是在闲鱼上买车，水太深了，一直在纠结，女友真的很关心我！，几乎时不时的都会来问我选的怎么样的，我的回答还是，再看看，因为价位没有确定，我也不知道具体买哪个所以就一直在观望。 到了十二月份，还没确定下来！女友可能以为是我钱不够没有买，还给我过生日发了520让我买车车，但是其实不是！而是车的种类太多了，太需要了解啦，不仅仅是品牌，各种配件的品牌我也了解了一下，所以就性价比这东西，还真挺多，但是具体买哪一辆真摸不准，所以还是一直在观望，直到现在都没有确定下来。 确定车车· 直到2024年的1月18号，这一天，我几乎是看了一天的自行车对比，最终选择了一辆自组的Gravel(瓜车)砾石公路车，简单说一下就是有着公路车的速度，又有着山地车的越野能力，轮胎比较耐磨，并且价格还行，这辆自行车就是我想要的自行车，恨自己没早发现这种车。 在2024年1月22号，激动的心，颤抖的手，终于把车买下来了，山东老表实诚。 期间小插曲· 其实买Gravel车的时候，我是参考了两家的，简称A和B两家，A家是我最先了解的，但是慢慢的B家被我发现性价比更高性能也更棒，但是B家由于太火爆，已经没有车辆发货了，要发也只能等到春节后的，但是我想过年前就入了，所以就无奈痛失，选择了A家的车。 但是到了第二天早上，B家老板给我打电话说，多出来了一辆，想直接给我安排走，当时我直接就不困了，无奈的给老板说已经买了别家的而且已经发货了，肯定没法再退了，老板说好吧，但是我的内心也是真的很难受受，喜欢的突然有了但是又突然没了，落差感油然而生，但是好在买到了自行车！ 到货· 2024年1月24日，上午，新车终于到货了！ 拆出来后的样子，新车的感觉就是不错！ 老板也很大方，送了水壶架、头盔、扳手之类的赠品。 组装过程直接略过了，我的动手能力还可以，期间听说过很多人买了自行车，需要调试，说调试很麻烦，我一开始也怕我不会这个该怎么办，但是当我组装好了以后，我就知道怎么回事儿了，主要是刹车蹭碟的问题，调整一下位置就好了，没有过多的调试，我和我妈我来就把自行车给组装好了！ 上成品！ 这张图是组装好后的，第一张图直接拍的，也没考虑角度，矿泉水纯属就是测测架子怎么用的，有点突兀，就当纪念新车的诞生！ 开始骑行· 2024年1月24号，也就是组装好车的当天下午，天气晴朗，我妈要去办理一些东西，我就顺便来试试车，就跟着去了！第一次骑上车的感觉，很美好，觉得我开始享受生活了哈哈。 骑完的感觉就是，还挺累的，没有我想象的轻松哈哈，但是运动都是要坚持的！ 提车当天骑了13公里，因为是城市道路，红绿灯比较多，整体下来，还是非常爽的，既可以锻炼，也可以去到自己想去的地方。远行！ 新车第一张看着还不错的照片，当天的天气特别好，就骑到了游乐园里，并拍了一张。 骑车给了我一种你去哪不重要，重要的是你要去的感觉，于是第二天，我就带着我的之前买的小相机，去骑行到自己想去的地方，但是还是不远行，一是是没有经验，二是还没达到那个程度，但是慢慢努力！ 第二天我就准备出发去日月湖，以前去过，但是从没有骑行着去过，感觉这个地方的湖水很美。 这天大约骑了23公里，时速慢是因为车流量很大加上红绿灯然后没有暂停计时，不过这都无关紧要，路上的风景要远比这些更美好。 其实对自己的选择也很觉得很幸运，有一个支持自己的女友，还很幸运的选择了一些喜欢的事情，比如吉他、摄影、骑车等，虽然这些都是爱好，但是这些爱好却能让我有动力去坚持，去努力，去生活，去享受。 女友买的手套· 因为毕竟是快要过年了，女友知道我现在非常喜欢骑车，但是考虑到冬天比较冷，就提前给我买了一个手套，一开始我还不知道，她问我今天出去骑车不，我说去呀，一会儿就准备去啦，她就让我必须先去拿快递再去骑车，我心想什么是东东！但是女友没告诉我，知道我拿到才发现是手套！很保暖的手套！手心的材质还类似于人的指纹(应该是什么皮料)，摸上去很舒服，而且手感很好，戴在手上骑车真的感觉特别棒！ 女友买的手套🧤 对于这个手套，在那一阵子还是零下七八度的时候，真的是起到了非常重要的作用，真的很温暖，很冷的天出去骑一骑车，手还是暖暖的，很舒服。 另外和女友这几天玩蛋仔也是一直胜利！ 大雪将至· 在2024年1月最后一天的晚上，河南开始下起了持续大约一周的大雪，在开始下雪之前，我正在外面骑车，然后突然开始嘀嗒嘀嗒的下起了小雪花，一开始没有在意，后面越来越大，不一会儿路面湿透了，我就赶紧赶紧回家了。 这场雪，可以说是河南很多年以来最大的一场雪了，是那种持续着下不带停的那种。女友下雪也是超级好看！ 总结就是：雪下的特别大，没有地方骑车，在地下车库骑了几次，但是不太爽。 直到2.7号路面的雪才清理化的差不多，终于可以骑车啦！ 我就去开始了环绕古城！丰富自己的能力。 骑行不仅仅是锻炼，我更想把它理解为是一种修行，在风中骑行，在风中感悟，欣赏路上的风景。 梦想从来不会逃走，逃走的永远是你自己！ —— 《破风》 2024.2.15· 新车买过来到现在也是二十来天啦，除去了下大雪的一周，也是骑行了240+公里了，从一开始的骑的贼慢贼累，到现在已经可以骑行小长距离，这是一个成长的过程，也是对自己所以喜欢的事物的回报。 现在已经可以在老家来回穿梭了，这种感觉是从未有过的爽！ 速度越来越快，越来越顺滑，越来越享受，越来越期待下一次的骑行！ 谢谢骑行可以带来这么多的乐趣，还有女朋友支持我！也谢谢越来越勇敢的自己。","categories":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://sawr.gitee.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"骑行","slug":"骑行","permalink":"https://sawr.gitee.io/tags/%E9%AA%91%E8%A1%8C/"}]},{"title":"五彩纸屑特效JS插件快速使用","slug":"js/confetti","date":"2023-11-09T16:00:00.000Z","updated":"2024-04-10T09:21:22.699Z","comments":true,"path":"2023/11/10/js/confetti/","link":"","permalink":"https://sawr.gitee.io/2023/11/10/js/confetti/","excerpt":"","text":"突然想给树洞做一个发布的时候来一个撒花效果，但是自己做没有什么思路，然后就在 GitHub 冲浪的时候发现了这个 JS 库，这就是我想要的效果，这是我的梦中情库！GitHub 上目前已有5.9k Star 项目地址：catdad/canvas-confetti: 🎉 performant confetti animation in the browser (github.com) 这个项目提供了非常多的五彩纸屑的效果，效果都是特别好的，而且代码也是开源的。 安装方式： 常规 NPM 安装 1npm install --save canvas-confetti JS 引用 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.0/dist/confetti.browser.min.js&quot;&gt;&lt;/script&gt; 接下来我会进行展示插件的所有效果，由于原作者的网站是英文，所以我扒了官方网站的代码并进行了中文翻译展示在下面，所有效果都可以复制代码方便进行调用。 你可以访问 canvas confetti 以进行全屏浏览。 我这里只使用到了 JS 引用的方式进行说明，因为这个方便快速，而且源代码体积也特别小，加载速度比较快。 开源伟大！ 接下来就是在代码中进行调用。 我这里以 HTML 代码为例。 首先在项目中引用外部 JS 文件。 随便找一个效果,随便定义一个函数，把代码放到函数内。 1234567891011121314151617181920212223242526272829303132333435function a() { var count = 200; var defaults = { origin: { y: 0.7 }, }; function fire(particleRatio, opts) { confetti({ ...defaults, ...opts, particleCount: Math.floor(count * particleRatio), }); } fire(0.25, { spread: 26, startVelocity: 55, }); fire(0.2, { spread: 60, }); fire(0.35, { spread: 100, decay: 0.91, scalar: 0.8, }); fire(0.1, { spread: 120, startVelocity: 25, decay: 0.92, scalar: 1.2, }); fire(0.1, { spread: 120, startVelocity: 45, }); } 页面中添加一个按钮，调用该函数。 1&lt;button id=&quot;btn&quot; onclick=&quot;a()&quot;&gt;开始&lt;/button&gt; 打开页面调试，单击按钮，显示效果 别的效果更改例子代码即可。","categories":[{"name":"前端","slug":"前端","permalink":"https://sawr.gitee.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sawr.gitee.io/tags/JavaScript/"},{"name":"教程","slug":"教程","permalink":"https://sawr.gitee.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"搭建一个专属于自己的运动网站","slug":"life/running","date":"2023-10-27T16:00:00.000Z","updated":"2024-05-03T06:06:36.675Z","comments":true,"path":"2023/10/28/life/running/","link":"","permalink":"https://sawr.gitee.io/2023/10/28/life/running/","excerpt":"","text":"Running Page 是 @yihong0618 创立的一个开源项目，通过这个项目可以从多个主流跑步平台同步锻炼数据，自动生成一个地图可视化的跑步页面。通过 GitHub Pages 可以快速的完成自动部署。 支持以下平台设备 Strava Nike Run Club Garmin Garmin-cn Keep 悦跑圈 咕咚 GPX TCX Tcx+Strava(upload all tcx data to strava) Gpx+Strava(upload all tcx data to strava) Nike+Strava(Using NRC Run, Strava backup data) Garmin_to_Strava(Using Garmin Run, Strava backup data) Strava_to_Garmin(Using Strava Run, Garmin backup data) 搭建准备· Node.js· 官网：Node.js (nodejs.org) Git· 官网：Git - Downloading Package (git-scm.com) Python· 官网：python.org 这些都是老朋友了，要想快速搞，环境不能少。 开始搭建· 克隆项目 1git clone https://github.com/yihong0618/running_page.git 依次执行 123pip3 install -r requirements.txt yarn install yarn develop 到最后终端显示如下即可打开http://localhost:5173/查看。 默认打开的是原作者的数据，所以我们需要来制作自己的数据。 修改代码· 首先打开 .github/workflows 下的 run_data_sync.yml 文件，定位到第 22 行代码的位置。 RUN_TYPE填入你平时在用的运动 App，例如 keep，下面的 ATHLETE、TITLE、GITHUB_NAME、GITHUB_EMAIL，分别更改为自己的昵称、最终呈现在网站的热力图的标题、GitHub ID 和邮箱。 个性化设置· 在仓库目录下找到 src/static/site-metadata.ts，找到以下内容并修改成你自己想要的。 12345678910111213141516siteMetadata: { siteTitle: &#39;Running Page&#39;, #网站标题 siteUrl: &#39;https://yihong.run&#39;, #网站域名 logo: &#39;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQTtc69JxHNcmN1ETpMUX4dozAgAN6iPjWalQ&amp;usqp=CAU&#39;, #左上角 LOGO description: &#39;Personal site and blog&#39;, navLinks: [ { name: &#39;Blog&#39;, #右上角导航名称 url: &#39;https://yihong.run/running&#39;, #右上角导航链接 }, { name: &#39;About&#39;, url: &#39;https://github.com/yihong0618/running_page/blob/master/README-CN.md&#39;, }, ], }, 修改 src/utils/const.ts 文件中的样式： 1234// styling: 关闭虚线：设置为 `false` const USE_DASH_LINE = true; // styling: 透明度：[0, 1] const LINE_OPACITY = 0.4; 隐私保护：设置下面环境变量： 1234567891011# 忽略每个 polyline 的起点和终点的长度（单位：米）。 IGNORE_START_END_RANGE = 200 # 忽略下面 polyline 中每个点的距离的圆圈（单位：米）。 IGNORE_RANGE = 200 # 包含要忽略的点的折线。 IGNORE_POLYLINE = ktjrFoemeU~IorGq}DeB # 在保存到数据库之前进行过滤，你会丢失一些数据，但可以保护你的隐私，如果你使用的是公共仓库，建议设置为 1。不设置可关闭。 IGNORE_BEFORE_SAVING = 1 找到到 assets 文件夹，只保留其中的 3 个文件：start.svg、end.svg、grid.svg、index.tsx，将其余的 svg 文件删除，因为其他的文件都是原作者的，我们不需要。 到 src/static 文件夹，删除其中的 activities.json 文件. 到 run_page 文件夹，删除其中的 data.db 文件。 配置Keep· 确保自己的账号能用手机号 + 密码登陆 (不要忘记添加 secret 和更改自己的账号，在 GitHub Actions 中), 注：海外手机号需要换成国内 +86 的手机号 在终端输入以下命令： 1python run_page/keep_sync.py 手机号 密码 运行完成以后就会在代码文件夹中的相应位置，生成我们需要的运动数据，具体体现为文件夹中新增了两个文件，分别是 activities.json 和 data.db 文件，就是我们之前删除的。 生成数据展示· 可以改下方参数 (–special-distance 10 --special-distance2 20, 10km~20km 展示为 special-color1 20km 以上展示为 special-color2, --min-distance 10.0 用来筛选 10km 以上的) 1python run_page/gen_svg.py --from-db --title &quot;${{ env.TITLE }}&quot; --type github --athlete &quot;${{ env.ATHLETE }}&quot; --special-distance 10 --special-distance2 20 --special-color yellow --special-color2 red --output assets/github.svg --use-localtime --min-distance 0.5 例如： 1python run_page/gen_svg.py --from-db --title &quot;累计跑步热力图&quot; --type github --athlete &quot;奥奥的跑步日记&quot; --special-distance 10 --special-distance2 20 --special-color yellow --special-color2 red --output assets/github.svg --use-localtime --min-distance 0.5 1python run_page/gen_svg.py --from-db --title &quot;${{ env.TITLE_GRID }}&quot; --type grid --athlete &quot;${{ env.ATHLETE }}&quot; --output assets/grid.svg --min-distance 10.0 --special-color yellow --special-color2 red --special-distance 20 --special-distance2 40 --use-localtime 例如：我这个是2KM-10KM 1python run_page/gen_svg.py --from-db --title &quot;五公里以上&quot; --type grid --athlete &quot;奥奥的跑步日记&quot; --output assets/grid.svg --min-distance 5 --special-color yellow --special-color2 red --special-distance 5 --special-distance2 20 --use-localtime 生成年度环形数据 1python run_page/gen_svg.py --from-db --type circular --use-localtime 生成完毕以后就可以查看自己的数据了，我在2020年的时候还是一个积极运动的热血青年，现在也是青年但是不够热血，我要多跑跑步。 配置GitHub· 新建一个仓库，名字都无所谓。 把代码推送到GitHub仓库中。 123456git init git add . git commit -m &quot;first commit&quot; git branch -M main git remote add origin https://github.com/shaoao/running.git git push -u origin main 执行完毕以后就可以看到代码已经跑到GitHub仓库里了。 GitHub 仓库配置密钥和 Token· 配置仓库· 这个项目的作者在代码中用到了GitHub Actions自动化技术，每天会自动运行一次 Run Data Sync，可以及时地将我们的运动数据更新到网站上。 配置密钥，我们要按照下图进行操作，打开仓库的 Settings 页面，左侧切换到 Secrets and vairables 选项卡，点击右上角的 New repository secret，需要我们填入密钥名称 Name 和值 Value。 这里的密钥名称取决于你目前正在使用的运动 App，不同 App 的密钥名称存在着区别，查看密钥名称需要打开 .github/workflows/run_data_sync.yml 文件。 以我在用的 Keep 为例，它的两个密钥名称分别为 KEEP_MOBILE 和 KEEP_PASSWORD，它们的 Value 值其实分别对应——注册 Keep 账号的手机号和密码。 配置Token· 为了方便可以直接打开Personal Access Tokens进入，然后点击右上角的 Generate new token，生成一个新的 Token。 打开会让你输入密码验证，生成 Token 时，有两个注意点，将 Token 的有效期 Expiration 设置为 No expiration(长期有效)，勾选下面的所有复选框，将所有权限都打开。 生成的Token 接下来依次点击「Actions」&gt;「Run Data Svnc」&gt;「Run workflow」执行数据同步。 这样就会每天都把keep的数据给同步到网站上了。 接下来就是部署了，很简单就不解释了。","categories":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://sawr.gitee.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://sawr.gitee.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"运动","slug":"运动","permalink":"https://sawr.gitee.io/tags/%E8%BF%90%E5%8A%A8/"}]},{"title":"PicGo+Gitee 打造最强图床","slug":"tools/picgo","date":"2023-10-24T16:00:00.000Z","updated":"2024-04-20T15:42:27.311Z","comments":true,"path":"2023/10/25/tools/picgo/","link":"","permalink":"https://sawr.gitee.io/2023/10/25/tools/picgo/","excerpt":"","text":"平常写文章展示图片都是使用的第三方图片托管服务，这些第三方服务有可能会是不是无法访问，严重的可能会跑路，那么图片就无法显示了，因为GitHub的国内访问速度太慢了，所以为了方便自己展示图片然后速度也得到 事先准备· PicGo 安装· 官网：PicGo PicGo是开源的，有Electron基础可以二次开发，GitHub地址：PicGo Node.js· 官网：Node.js (nodejs.org) Git· 官网：Git - Downloading Package (git-scm.com) 这些是实现功能的基础，所以必须要有。 开始配置· 当你下载完毕以后，打开PicGo - 插件设置 - 搜索gitee - 选择gitee-uploader 我这里已经安装了所以会显示已安装。 配置Gitee· 新建仓库的时候勾选。 右上角头像 - 账号设置 - 左侧列表选择私人令牌 - 生成新令牌 只选择project即可，因为只用到这个权限。 然后根据提示生成了一串Token，建议复制保存到一个地方，因为这个Token只出现这一次，所以保存好。 配置PicGo· 我们已经事先安装好了Gitee插件，所以我们直接打开图床设置 设置完成以后直接保存，然后就可以进行使用了。 PS：Gitee上传图片之前最后压缩以下不要超过1MB，不然有可能会需要登陆显示。 防盗链· 如果你使用其他服务来访问该图床提供的服务，那么就需要破解Gitee的防盗链来达到目的。 这也是我在搭建完成图床以后，发现的问题，所以了解了一下，然后记录在这里，一次性解决多个问题吧算是，开源伟大。 什么是防盗链· 防盗链不是一根链条，正确的停顿应该是防·盗链——防止其他网站盗用我的链接。 我把图片上传到gitee的服务器，得到了图片的链接，然后拿着这个链接在第三方编辑器中使用，这就是在“盗用”——因为这张图片占用了gitee的服务器资源，却为第三方编辑器工作，gitee得不到好处，还得多花钱。 如何实现防盗链· 要实现防盗链，就需要知道图片的请求是从哪里发出的。可以实现这一功能的有请求头中的origin和referer。origin只有在XHR请求中才会带上，所以图片资源只能借助referer。其实gitee也确实是这么做的。 通过判断请求的referer，如果请求来源不是本站就返回302，重定向到gitee的logo上，最后在第三方网站引用存在gitee的资源就全变成它的logo了。 首先请求正常的图片，但是没有返回200，而是302重定向，其中响应头中的location就是要重定向去向的地址，如果没有就是不显示。 接着浏览器会自动请求这个location，并用这个返回结果代替第一次请求的返回内容。 最后，我们的图片在第三方网站就变成gitee的logo或者直接不显示。 破解防盗链· 想让Gitee不知道我在盗用，就不能让他发现请求的来源是第三方，要把referer藏起来才行。 HTML添加以下代码 1&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; 或者 1&lt;img referrer=&quot;no-referrer|origin|unsafe-url&quot; src=&quot;{item.src}&quot;/&gt; 配置文件 head 1234head: [ // 破解Gitee防盗链 [&quot;meta&quot;, { name: &quot;referrer&quot;, content: &quot;no-referrer&quot; }], ], Vue 可以在vue中的public文件夹下的index.html文件加入代码 1&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;","categories":[{"name":"tools","slug":"tools","permalink":"https://sawr.gitee.io/categories/tools/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://sawr.gitee.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"图床配置","slug":"图床配置","permalink":"https://sawr.gitee.io/tags/%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE/"}]},{"title":"Tailwind CSS教程","slug":"css/tailwind","date":"2023-10-17T16:00:00.000Z","updated":"2024-04-10T09:18:19.772Z","comments":true,"path":"2023/10/18/css/tailwind/","link":"","permalink":"https://sawr.gitee.io/2023/10/18/css/tailwind/","excerpt":"","text":"Tailwind CSS 是一个高度可定制的 CSS 框架，它提供了一系列的预定义样式和实用工具类，帮助开发者快速构建现代化的网页界面，可以直接应用于HTML元素，从而快速而灵活地创建页面布局和设计。 之前有介绍过DaisyUI，这个东西就是基于TailwindCss来进行开发的，很方便很好用。 官网：Tailwind CSS 特点· 原子级别的 CSS 类：Tailwind CSS 提供了一组小而独立的 CSS 类，每个类对应一个具体的样式属性或效果，例如颜色、边距、宽度等。通过组合这些类，开发者可以精确地控制样式，同时避免编写大量重复的 CSS 代码。 高度可定制：Tailwind CSS 允许开发者通过配置文件来自定义项目中使用的样式和工具类，可以添加、删除或修改现有的样式设置，以适应特定的设计需求。 响应式设计支持：Tailwind CSS 提供了一套响应式设计的工具类，使开发者可以轻松地在不同屏幕尺寸下调整布局和样式。 效率与一致性：通过使用 Tailwind CSS，开发者可以快速构建一致性强、易于维护的界面，无需手动编写和管理大量的 CSS 样式表。 用官方的话来说：只需书写HTML代码，无需书写CSS，即可快速构建美观的网站。 科普一下什么是原子化的CSS 比如我们正常开发写CSS是这样的 12345678&lt;div class=&quot;tittle&quot;&gt;标题&lt;/div&gt; &lt;style&gt; .tittle{ font-size: 18px; color:white; } &lt;/style&gt; 在html代码中指定class，然后在css里定义这个class的样式，也就是一个class里包含了多个样式。 而原子化css就是定义多个class，每个class包含一个样式，例如： 1&lt;div class=&quot;text-base p-1 border border-black border-solid&quot;&gt;&lt;/div&gt; 123456789101112131415.text-base { font-size: 16px; } .p-1 { padding: 4px; } .border { border-width: 1px; } .border-black { border-color: black; } .border-solid { border-style: solid; } 好理解吧，这种属于是细粒度的class，叫做原子class，然后引用这些class。 而TailWindCSS就是定义了非常多的这种class方便你进行引用的一个css框架。 快速安装入门· 本文是基于Vue3来进行安装使用的。 安装 Tailwind CSS 和 PostCSS 插件： 1npm install tailwindcss postcss autoprefixer 在项目根目录下创建一个 tailwind.config.js 文件，用于配置 Tailwind CSS： 12345678910111213141516// tailwind.config.js module.exports = { mode: &#39;jit&#39;, purge: [ &#39;./src/**/*.{vue,js,ts,jsx,tsx}&#39;, &#39;./public/index.html&#39; ], darkMode: false, // or &#39;media&#39; or &#39;class&#39; theme: { extend: {}, }, variants: { extend: {}, }, plugins: [], } 在项目根目录下创建一个 postcss.config.js 文件，用于配置 PostCSS 插件： 1234567// postcss.config.js module.exports = { plugins: { tailwindcss: {}, autoprefixer: {}, }, } 在src/index.css创建一个css文件，引入TailwindCSS的内容 123@tailwind base; @tailwind components; @tailwind utilities; 然后在main.js中引入这个css： 12345import { createApp } from &#39;vue&#39; import &#39;./style.css&#39; // 引入前面添加的css import &#39;./index.css&#39; import App from &#39;./App.vue&#39; createApp(App).mount(&#39;#app&#39;) 然后就可以进行使用了！ 123456789&lt;template&gt; &lt;div class=&quot;flex items-center justify-center h-screen bg-gray-100&quot;&gt; &lt;div class=&quot;p-6 bg-white rounded-lg shadow-lg&quot;&gt; &lt;h1 class=&quot;text-2xl font-bold text-gray-800&quot;&gt;Hello Tailwind CSS!&lt;/h1&gt; &lt;p class=&quot;mt-2 text-gray-600&quot;&gt;Lorem ipsum dolor sit amet.&lt;/p&gt; &lt;button class=&quot;px-4 py-2 mt-4 text-white bg-blue-500 rounded hover:bg-blue-600&quot;&gt;Click me!&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; 我写过一篇关于DaisyUI框架的内容，是基于本框架实现的。 插件· 由于这个命令太多而且较难记住，所以可以在VSCode 中可以安装 Tailwind CSS IntelliSense 插件 这样写 Tailwind CSS 会有提示，而且当鼠标悬浮到class上时，也会有有智能提示，可以查看它对应的样式。 常用写法· 宽和高· 以w-开头，表示宽;h-开头，表示高 后面接数字，1 = 4px = 0.25rem 123456789101112131415161718/* 普通数值 */ w-1 //width: 0.25rem; /* 4px */ w-4 //width: 1rem; /* 16px */ /* 百分比 */ w-1/2 //width: 50%; w-1/4 //width: 25%; /* 后面接 [] 里面可以填写具体的值 */ w-[4rem] // width: 4rem; w-[200px] // width: 200px; /* 固定单词 */ w-full //width: 100%; w-screen //width: 100vw; w-min //width: min-content; w-max //width: max-content; w-fit //width: fit-content; 边距· margin的缩写是 m 123m-1 // margin: 4px; mx-1 // 在x轴上 margin-left: 4px; margin-right: 4px; my-1 // 在y轴上 margin-top: 4px; margin-bottom: 4px; padding 的缩写是p,使用方式与margin一样 123p-1 // padding: 4px; px-1 // 在x轴上 padding-left: 4px; padding-right: 4px; py-1 // 在y轴上 padding-top: 4px; padding-bottom: 4px; 为单边添加边距: 使用 m{t|r|b|l}-{size} 实用程序控制元素一侧的边距。 1234567891011/* margin */ &lt;div class=&quot;mt-4&quot;&gt;上&lt;/div&gt; &lt;div class=&quot;mr-4&quot;&gt;右&lt;/div&gt; &lt;div class=&quot;mb-4&quot;&gt;下&lt;/div&gt; &lt;div class=&quot;ml-4&quot;&gt;左&lt;/div&gt; /* padding */ &lt;div class=&quot;pt-4&quot;&gt;上&lt;/div&gt; &lt;div class=&quot;pr-4&quot;&gt;右&lt;/div&gt; &lt;div class=&quot;pb-4&quot;&gt;下&lt;/div&gt; &lt;div class=&quot;pl-4&quot;&gt;左&lt;/div&gt; 字体大小· 字体大小，使用 text-&#123;size&#125;。不同的值对应不同的大小 12345678text-xs //（字体大小：.75rem；） text-sm //（字体大小：.875rem；） text-base //（字体大小：1rem;） text-lg //（字体大小：1.125rem；） text-xl //（字体大小：1.25rem；） text-2xl //（字体大小：1.5rem；） text-3xl //（字体大小：1.875rem；） text-4xl //（字体大小：2.25rem；) 同样可以使用[]定义大小 1text-[14px] // font-size:14px hover悬停· 使用hover,设置鼠标悬停后文本设为红色 123&lt;div class=&quot; hover:text-red-400&quot;&gt; TailWind css &lt;/div&gt; 响应式设计· Tailwind 中的每个实用程序类都可以有条件地应用于不同的断点，这使得在不离开 HTML 的情况下构建复杂的响应式接口变得轻而易举。 默认情况下有五个断点，受常见设备分辨率的启发： 断点前缀 最小宽度 CSS sm 640px 640像素 @media (min-width: 640px) &#123; ... &#125; md 768px 768像素 @media (min-width: 768px) &#123; ... &#125; lg 1024px 1024像素 @media (min-width: 1024px) &#123; ... &#125; xl 1280px 1280像素 @media (min-width: 1280px) &#123; ... &#125; 2xl 1536px 1536像素 @media (min-width: 1536px) &#123; ... &#125; 例如：当宽度小于768px，把背景变为红色 123&lt;div class=&quot;md:bg-red-500&quot;&gt; TailWind css &lt;/div&gt; 使用flex布局· flex-row：水平排列子元素。 flex-col：垂直排列子元素。 flex-wrap：当子元素超出容器宽度时换行。 justify-start、justify-end、justify-center、justify-between、justify-around：控制子元素在主轴上的对齐方式。 items-start、items-end、items-center、items-baseline、items-stretch：控制子元素在交叉轴上的对齐方式。 flex-1：将子元素的宽度或高度设置为 1，以填充剩余的空间。 简单导航栏· 12345678&lt;nav class=&quot;flex justify-between items-center p-4 bg-gray-800 text-white&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;font-bold&quot;&gt;Logo&lt;/a&gt; &lt;ul class=&quot;flex&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;mx-2&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;mx-2&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;mx-2&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; 使用了 flex、justify-between 和 items-center 类来实现导航栏的布局。子元素 a 和 ul 都被包裹在 nav 元素中，ul 元素上的 flex 类使其成为一个 flex 容器，子元素 li 和 a使用了 margin 类来实现间距。 常见布局· 两栏布局 12345678910&lt;div class=&quot;flex&quot;&gt; &lt;!-- 左侧栏 --&gt; &lt;div class=&quot;w-1/4 bg-gray-100&quot;&gt; &lt;p&gt;左侧栏&lt;/p&gt; &lt;/div&gt; &lt;!-- 右侧内容 --&gt; &lt;div class=&quot;w-3/4&quot;&gt; &lt;p&gt;右侧内容&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 三栏布局 1234567891011121314&lt;div class=&quot;flex&quot;&gt; &lt;!-- 左侧栏 --&gt; &lt;div class=&quot;w-1/4 bg-gray-100&quot;&gt; &lt;p&gt;左侧栏&lt;/p&gt; &lt;/div&gt; &lt;!-- 主要内容 --&gt; &lt;div class=&quot;w-1/2&quot;&gt; &lt;p&gt;主要内容&lt;/p&gt; &lt;/div&gt; &lt;!-- 右侧栏 --&gt; &lt;div class=&quot;w-1/4 bg-gray-100&quot;&gt; &lt;p&gt;右侧栏&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 等分布局 1234567891011&lt;div class=&quot;flex&quot;&gt; &lt;div class=&quot;flex-1 p-4 bg-gray-100&quot;&gt; &lt;p&gt;等分1/3&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;flex-1 p-4 bg-gray-200&quot;&gt; &lt;p&gt;等分1/3&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;flex-1 p-4 bg-gray-300&quot;&gt; &lt;p&gt;等分1/3&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 响应式布局 12345678910111213141516&lt;div class=&quot;flex flex-col md:flex-row&quot;&gt; &lt;!-- 左侧栏 --&gt; &lt;div class=&quot;w-full md:w-1/3 p-4 bg-gray-100&quot;&gt; &lt;h2 class=&quot;text-lg font-medium mb-4&quot;&gt;左侧栏&lt;/h2&gt; &lt;ul class=&quot;list-disc pl-4&quot;&gt; &lt;li&gt;Link 1&lt;/li&gt; &lt;li&gt;Link 2&lt;/li&gt; &lt;li&gt;Link 3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 右侧内容 --&gt; &lt;div class=&quot;w-full md:w-2/3 p-4 bg-white&quot;&gt; &lt;h2 class=&quot;text-lg font-medium mb-4&quot;&gt;右侧内容&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 黑白主题切换· 在 tailwind.config.js 配置文件中定义颜色变量。 123456789101112module.exports = { theme: { extend: { colors: { black: &#39;#000&#39;, white: &#39;#fff&#39;, }, }, }, variants: {}, plugins: [], } 在 App.vue 的 &lt;template&gt; 标签中添加一个切换主题的按钮，并使用 isDark 变量来切换主题。 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div :class=&quot;{ &#39;dark&#39;: isDark }&quot;&gt; &lt;div class=&quot;bg-white text-black&quot;&gt; &lt;p&gt;Some text&lt;/p&gt; &lt;/div&gt; &lt;button @click=&quot;toggleTheme&quot;&gt;Toggle theme&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { ref } from &#39;vue&#39; export default { setup() { const isDark = ref(false) const toggleTheme = () =&gt; { isDark.value = !isDark.value const html = document.querySelector(&#39;html&#39;) html.classList.toggle(&#39;dark&#39;) } return { isDark, toggleTheme, } }, } &lt;/script&gt; 使用 Tailwind CSS 的 dark 模式类来定义黑色主题，并使用颜色变量来设置背景和文本颜色。 123&lt;div class=&quot;bg-white text-black dark:bg-black dark:text-white&quot;&gt; &lt;p&gt;Some text&lt;/p&gt; &lt;/div&gt; 1234567891011121314/* tailwind.config.js */ module.exports = { theme: { extend: { colors: { black: &#39;#000&#39;, white: &#39;#fff&#39;, }, darkMode: &#39;class&#39;, }, }, variants: {}, plugins: [], } 完成上述操作，即可实现黑白切换。 daisyUI的黑白效果会更好一些，推荐。 记忆规律· 简写 全拼 m margin p padding t top r right b bottom l left x left &amp; right y top &amp; bottom s inline-start e inline-end px 1px col column full 100% min min-content max max-content fit fit-content screen 100vw leading line-height bg background rounded border-radius Class 举例 Properties p{t,r,b,l,x,y,s,e}-{size} p-0 padding: 0px; m{t,r,b,l,x,y,s,e}-{size} m-0 margin: 0px; w-{size} w-0 width: 0px; min-w-{size} min-w-0 min-width: 0px; max-w-{size} max-w-0 max-width: 0rem; h-{size} h-0 height: 0px; min-h-{size} min-h-0 min-height: 0px; max-h-{size} max-h-0 max-height: 0rem; grid-cols-{number} grid-cols-1 grid-template-columns: repeat(1, minmax(0, 1fr)); grid-rows-{number} grid-rows-1 grid-template-rows: repeat(1, minmax(0, 1fr)); col-span-{number} col-span-1 grid-column: span 1 / span 1; auto-cols-{size} auto-cols-auto grid-auto-columns: auto; auto-rows-{size} auto-rows-auto grid-auto-rows: auto; tracking-{size} tracking-tighter letter-spacing: -0.05em; leading-{size} leading-1 line-height: .25rem; scroll-m{t,r,b,l,x,y,s,e}-{size} scroll-m-0 scroll-margin: 0px; scroll-p{t,r,b,l,x,y,s,e}-{size} scroll-p-0 scroll-padding: 0px; 多态：多态是指一种模式对应多个属性。 Class 举例 Properties object-{value} object-contain object-fit: contain; object-{side} object-bottom object-position: bottom; flex-{direction} flex-row flex-direction: row; flex-{value} flex-wrap flex-wrap: wrap; flex-{number} flex-1 flex: 1 1 0%; font-{sans,serif,mono} font-serif font-family: ui-serif, Georgia, Cambria, “Times New Roman”, Times, serif; font-{weight} font-thin font-weight: 100; list-{value} list-inside list-style-position: inside; list-{value} list-disc list-style-type: disc; text-{size} text-xs font-size: 0.75rem; line-height: 1rem; text-{side} text-left text-align: left; text-{color} text-black color: rgb(0 0 0); text-{ellipsis,clip} text-ellipsis text-overflow: ellipsis; decoration-{color} decoration-current text-decoration-color: currentColor; decoration-{value} decoration-solid text-decoration-style: solid; decoration-{size} decoration-0 text-decoration-thickness: 0px; bg-{attachment} bg-fixed background-attachment: fixed; bg-{color} bg-current background-color: currentColor; bg-{side} bg-bottom background-position: bottom; bg-{auto,cover,contain} bg-auto background-size: auto; border-{size} border-0 border-width: 0px; border-{color} border-black border-color: rgb(0 0 0); border-{value} border-dashed border-style: dashed; outline-{size} outline-0 outline-width: 0px; outline-{color} outline-current outline-color: currentColor; outline-{value} outline-dashed outline-style: dashed; outline-{size} outline-offset-0 outline-offset: 0px; shadow-{size} shadow-sm box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); shadow-{color} shadow-black –tw-shadow-color: #000; snap-{value} snap-start scroll-snap-align: start; snap-{normal,always} snap-normal scroll-snap-stop: normal; snap-{value} snap-x scroll-snap-type: x var(–tw-scroll-snap-strictness); 其他 Class 举例 Properties isolation-auto isolation: auto; invisible visibility: hidden; flex-1 flex: 1 1 0%; flex-auto flex: 1 1 auto; flex-initial flex: 0 1 auto; grow flex-grow: 1; shrink flex-shrink: 1; order-first order: -9999; order-last order: 9999; order-none order: 0; row-auto grid-row: auto; row-span-full grid-row: 1 / -1; gap-x-{size} gap-x-0 column-gap: 0px; gap-y-{size} gap-y-0 row-gap: 0px; subpixel-antialiased -webkit-font-smoothing: auto; not-italic font-style: normal; normal-nums font-variant-numeric: normal; list-image-none list-style-image: none; no-underline text-decoration-line: none; normal-case text-transform: none; truncate overflow: hidden;text-overflow: ellipsis;white-space: nowrap; break-normal overflow-wrap: normal;word-break: normal; break-words overflow-wrap: break-word; break-keep word-break: keep-all; inset-x-{size} inset-x-0 left: 0px;right: 0px; inset-y-{size} inset-y-0 top: 0px;bottom: 0px; line-clamp-{number} line-clamp-1 overflow: hidden;display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 1; bg-no-repeat background-repeat: no-repeat; bg-gradient-{direction} bg-gradient-to-t background-image: linear-gradient(to top, var(–tw-gradient-stops)); outline-none outline: 2px solid transparent;outline-offset: 2px; outline outline-style: solid; resize-y resize: vertical; resize-x resize: horizontal; resize resize: both; snap-align-none scroll-snap-align: none; 影响基础样式· Tailwind css会默认将一些基础样式设置为普通文字样式，包括以下几种： 在Tailwindcss中 h1到 h6 标签，所有标题元素，其字体大小与字体粗细与普通文本无差别。 在Tailwindcss中 有序列表和无序列表: ul,li默认情况下是无样式的，没有符号标记和数字，同时也没有外边距和内边距 在Tailwindcss中 标题、块引用、段落等元素的所有默认外边距。 正常情况下图片、svg、video、canvas是行内块元素， 在Tailwindcss中 默认设置为 display:block Tailwindcss重写了border所有元素的默认边框样式。 如果想去掉影响的这些部分，那么可以： 注释掉 @tailwind base; ,里面存放的是tailwind重写原生标签后的初始样式,把它删了就可以解决上面的一些问题，但可能也会导致一些不可预料的问题。 123// @tailwind base; @tailwind components; @tailwind utilities; 或者 在全局的css文件里 重写样式,用@layer base重新自定义样式; @layer指令，Tailwind 将自动将这些样式移到 @tailwind base的同一位置，以避免出现一些意 12345678910111213141516@tailwind base; @tailwind components; @tailwind utilities; // 自定义样式 @layer base { h1 { @apply text-2xl; } h2 { @apply text-xl; } h3 { @apply text-lg; } } 参考· Vue中使用 Tailwind CSS Tailwind css 在项目中的使用与问题 感谢！","categories":[{"name":"前端","slug":"前端","permalink":"https://sawr.gitee.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://sawr.gitee.io/tags/CSS/"}]},{"title":"哔哩哔哩视频嵌入最详细教程","slug":"tutorial/biliqianru","date":"2023-10-04T06:20:00.000Z","updated":"2024-04-10T09:28:37.919Z","comments":true,"path":"2023/10/04/tutorial/biliqianru/","link":"","permalink":"https://sawr.gitee.io/2023/10/04/tutorial/biliqianru/","excerpt":"","text":"之前图床服务出现问题导致图片无法加载，请见谅。 哔哩哔哩支持使用iframe来嵌入视频，并且不会卡顿。演示的视频我都添加了&amp;muted=1参数，目的是静音播放不惊吓各位。 我们搭建一些博客或者一些别的个人网站，可能是出于兴趣爱好，并不会买一台几百兆带宽的服务器或者是购买国内CND来进行加速，如果把视频塞到自己的服务器中，那么效果肯定是不太行。 那应该怎么办呢！ 不怕！哔哩哔哩在很久之前就已经支持iframe嵌入播放器了！而且支持代码一键复制，只需要把复制的代码嵌入到你的网站中即可。 然后就会得到官方给的代码： 1&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=275949729&amp;bvid=BV1BF411D7LZ&amp;cid=1265069356&amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; 得到如下效果 修改官方代码· 这玩意看起来，效果有点拉拉跨，有点一言难尽，连个自适应也没给，这么小上面还带这么多大的文字提示，视觉观感一点儿也不行，这可怎么办呀！！ 别担心 一键复制的官方的东西，官方很懒这也没办法，不过咱们可以给他进行一个优化！ 1&lt;p&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=275949729&amp;bvid=BV1BF411D7LZ&amp;cid=1265069356&amp;p=1&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot; width=&quot;95%&quot; height=&quot;600&quot;&gt;&lt;/iframe&gt;&lt;/p&gt; 只需要把官方代码src=&quot;&quot;里面的链接替换到上方代码的src=&quot;&quot;链接即可得到下面的效果，就可以看到现在明显的不一样了。 在这里提供一个干净的代码，只需要把链接复制进去即可使用。 12// 把你拷贝的链接复制到 src=“链接” &lt;p&gt;&lt;iframe src=&quot;&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot; width=&quot;95%&quot; height=&quot;600&quot;&gt;&lt;/iframe&gt;&lt;/p&gt; 来看效果 这样看起来，感觉效果还不错，看着样子大小都还可以，感觉就可以直接拿来用了，如果只是电脑来浏览观看，那么这样已经足够了。 但是手机也是主要的浏览工具，来看一下手机版本怎么表现的。 可以看出来，手机端表现也还说得过去，这是一个横屏视频，视频比例没什么问题，就是把高度直接给用黑色填充了，这个黑色的完全没必要有，所以我们还需要对手机端进行适配才行。 解决手机端比例· 对于这个比例问题，有点像抖音那种短视频的感觉，就是横屏视频在竖屏浏览的时候填充黑色，很多已经习惯了抖音的这种感觉，所以就觉得问题不大，但是我们也可以把他给进行解决。 参考ExperDot大佬给出的方案 123&lt;div style=&quot;position: relative; padding: 30% 45%;&quot;&gt; &lt;iframe style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot; src=&quot;//player.bilibili.com/player.html?aid=275949729&amp;bvid=BV1BF411D7LZ&amp;cid=1265069356&amp;p=1&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 只需要把官方代码src=&quot;&quot;里面的链接替换到上方代码的src=&quot;&quot;链接即可 依旧提供干净代码 123&lt;div style=&quot;position: relative; padding: 30% 45%;&quot;&gt; &lt;iframe style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot; src=&quot;&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 效果 来看看手机端 这感觉就很完美了！！我直接奥里给太给力了吧。这样就基本实现了一整个把哔哩哔哩嵌入到网站里面的流程。 简洁优化播放器· 仔细看PC端的播放器界面 艾玛这界面杂乱的，看着我都有点不想看，这么臃肿的界面很难有一直看下去的想法，所以我们可以让他变得清爽一些。 尿素过多，直接上干货 其实哔哩哔哩很🐕，把PC端的播放器做的很花里胡哨，但是在移动端，一点点儿一捏捏广告都木有！！ 这不就很简单了，我们直接把移动端的播放器拿过来，在PC端上用，不就可以实现无广告的清纯界面辣！奥里给，直接上手开干。 掏出我们之前的代码 123&lt;div style=&quot;position: relative; padding: 30% 45%;&quot;&gt; &lt;iframe style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot; src=&quot;//player.bilibili.com/player.html?aid=275949729&amp;bvid=BV1BF411D7LZ&amp;cid=1265069356&amp;p=1&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 修改为 123&lt;div style=&quot;position: relative; padding: 30% 45%;&quot;&gt; &lt;iframe style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot; src=&quot;//www.bilibili.com/blackboard/html5mobileplayer.html?aid=275949729&amp;bvid=BV1BF411D7LZ&amp;cid=1265069356&amp;p=1&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 就是就是把源代码 src=&quot;&quot; 里的链接里的 //player.bilibili.com/player.html 换成了 //www.bilibili.com/blackboard/html5mobileplayer.html 而已，其余的代码我可一点儿都没动！ 上效果 哇塞塞！这效果属是不错，而且这界面确实干净整洁无异味，不是伪娘就是…咳咳说正题，这里在看KNIFE大佬写的文章的时候，发现这个代码，简单是简单，但是没有办法全屏。 想想就有点难过！如此干净的视频却没办法全屏欣赏！不答应！所以！ 上 最 终 法 宝！ 最终版播放器· 123&lt;div style=&quot;position: relative; padding: 30% 45%;&quot;&gt; &lt;iframe style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot; src=&quot;//www.bilibili.com/blackboard/html5mobileplayer.html?aid=275949729&amp;bvid=BV1BF411D7LZ&amp;cid=1265069356&amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 干净代码 123&lt;div style=&quot;position: relative; padding: 30% 45%;&quot;&gt; &lt;iframe style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot; src=&quot;//www.bilibili.com/blackboard/html5mobileplayer.html?&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 记得把?后面的链接粘贴到src中的最后面即可使用最强大的哔哩哔哩播放器了。 保姆教程 - 干净链接 你复制的链接是//player.bilibili.com/player.html?aid=275949729&amp;bvid=BV1BF411D7LZ&amp;cid=1265069356&amp;p=1 你只需要把aid=275949729&amp;bvid=BV1BF411D7LZ&amp;cid=1265069356&amp;p=1 复制粘贴到src=&quot;//www.bilibili.com/blackboard/html5mobileplayer.html?链接内容&quot; 变成src=&quot;//www.bilibili.com/blackboard/html5mobileplayer.html?aid=275949729&amp;bvid=BV1BF411D7LZ&amp;cid=1265069356&amp;p=1&quot;即可 哔哩哔哩播放器参数表· 参数用途 参数名 使用方法 是否自动播放(默认否) autoplay 1: 开启, 0: 关闭 默认弹幕开关(默认开启) danmaku 1: 开启, 0: 关闭 是否默认静音(默认否) muted 1: 开启, 0: 关闭 一键静音按钮是否显示(默认不显示 hasMuteButton 1: 开启, 0: 关闭 视频封面下方是都显示播放量弹幕量等信息(默认显示) hideCoverInfo 1: 开启, 0: 关闭 是否隐藏弹幕按钮（默认不隐藏） hideDanmakuButton 1: 开启, 0: 关闭 是否隐藏全屏按钮(默认显示) noFullScreenButton 1: 开启, 0: 关闭 是否开始记忆播放(默认开启) fjw 1: 开启, 0: 关闭 默认开始时间(默认0) t 直接填写数值，单位秒 是否显示高清(默认否） highQuality 1: 开启, 0: 关闭（貌似是无用的，各位可以试试） 使用方法 比如使用danmaku弹幕参数 1=开启，0=关闭，我们直接在该链接的最后加上一个 &amp; 符号，然后再将 danmaku=0 黏贴上去即可。 例如 //www.bilibili.com/blackboard/html5mobileplayer.html?aid=275949729&amp;bvid=BV1BF411D7LZ&amp;cid=1265069356&amp;p=1&amp;danmaku=0 把上面的链接复制到src中就可以实现关闭弹幕播放(有弹幕按钮后续想看可以开开) 可以添加多个参数，使用?隔开 //www.bilibili.com/blackboard/html5mobileplayer.html?aid=275949729&amp;bvid=BV1BF411D7LZ&amp;cid=1265069356&amp;p=1&amp;danmaku=0?&amp;muted=1 参考· 注：本文参考了一些别的博主写法，全文文字以及展示都是由个人撰写，文章通俗易懂也更加全面。","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://sawr.gitee.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://sawr.gitee.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"提高效率的10个方法","slug":"life/tigaoxiaolv","date":"2023-09-26T08:00:00.000Z","updated":"2024-04-10T09:00:26.358Z","comments":true,"path":"2023/09/26/life/tigaoxiaolv/","link":"","permalink":"https://sawr.gitee.io/2023/09/26/life/tigaoxiaolv/","excerpt":"","text":"1. 早上不要开会 📅· 每个人一天是 24 小时，时间是均等的，但是时间的价值却不是均等的，早上 1 小时的价值是晚上的 4 倍。为什么这么说？ 因为早晨是大脑的黄金时间，经过一晚上的睡眠，大脑经过整理、记录、休息，此时的状态是最饱满的，适合专注度高的工作，比如编程、学习外语等，如果把时间浪费在开会、刷手机等低专注度的事情上，那么就会白白浪费早上的价值。 2. 不要使用番茄钟 🍅· 有时候在专心编程的时候，会产生“心流”，心流是一种高度专注的状态，当我们专注的状态被打破的时候，需要 15 分钟的时候才能重新进入状态。 有很多人推荐番茄钟工作法，设定 25 分钟倒计时，强制休息 5 分钟，之后再进入下一个番茄钟。本人在使用实际使用这种方法的时候，经常遇到的问题就是刚刚进入“心流”的专注状态，但番茄钟却响了，打破了专注，再次进入这种专注状态需要花费 15 分钟的时间。 好的替换方法是使用秒表，它跟番茄钟一样，把时间可视化，但却是正向计时，不会打破我们的“心流”，当我们编程专注度下降的时候中去查看秒表，确定自己的休息时间。 3. 休息时间不要玩手机 📱· 大脑处理视觉信息需要动用 90% 的机能，并且闪烁的屏幕也会让大脑兴奋，这就是为什么明明休息了，但是重新回到工作的时候却还是感觉很疲惫的原因。 那么对于休息时间内，我们应该阻断视觉信息的输入，推荐： 闭目养神 😪 听音乐 🎶 在办公室走动走动 🏃‍♂️ 和同事聊会天 💑 扭扭脖子活动活动 💁‍♂️ 冥想 or 正念 🧘 4. 不要在工位上吃午饭 🥣· 大脑经过一早上的编程劳累运转之后，此时的专注度已经下降 40%~50%，这个时候我们需要去重启我们的专注度，一个好的方法是外出就餐，外出就餐的好处有： 促进血清素分泌：我们体内有一种叫做血清素的神经递质，它控制着我们的睡眠和清醒，外出就餐可以恢复我们的血清素，让我们整个人神经气爽： 日光浴：外出的时候晒太阳可以促进血清素的分泌 有节奏的运动：走路是一种有节奏的运动，同样可以促进血清素分泌 激发场所神经元活性：场所神经元是掌控场所、空间的神经细胞，它存在于海马体中，外出就餐时场所的变化可以激发场所神经元的活性，进而促进海马体活跃，提高我们的记忆力 激活乙酰胆碱：如果外出就餐去到新的餐馆、街道，尝试新的事物的话，可以激活我们体内的乙酰胆碱，它对于我们的“创作”和“灵感”起到非常大的作用。 5. 睡午觉 😴· 现在科学已经研究表现，睡午觉是非常重要的一件事情，它可以： 恢复我们的身体状态：26 分钟的午睡，可以让下午的工作效率提升 34%，专注力提升 54%。 延长寿命：中午不睡午觉的人比中午睡午觉的人更容易扑街 预防疾病：降低老年痴呆、癌症、心血管疾病、肥胖症、糖尿病、抑郁症等 睡午觉好处多多，但也要适当，15 分钟到 30 分钟的睡眠最佳，超过的话反而有害。 6. 下午上班前运动一下 🚴· 下午 2 点到 4 点是人清醒度最低的时候，10 分钟的运动可以让我们的身体重新清醒，提高专注度，程序员的工作岗位和场所如果有限，推荐： 1️⃣ 深蹲 2️⃣ 俯卧撑 3️⃣ 胯下击掌 4️⃣ 爬楼梯（不要下楼梯，下楼梯比较伤膝盖，可以向上爬到顶楼，再坐电梯下来） 7. 2 分钟解决和 30 秒决断 🖖· ⚒️ 2 分钟解决是指遇到在 2 分钟内可以完成的事情，我们趁热打铁把它完成。这是一个解决拖延的小技巧，作为一个程序员，经常会遇到各种各样的突发问题，对于一些问题，我们没办法很好的决策要不要立即完成， 2 分钟解决就是一个很好的辅助决策的办法。 💣 30 秒决断是指对于日常的事情，我们只需要用 30 秒去做决策就好了，这源于一个“快棋理论”，研究人员让一个著名棋手去观察一盘棋局，然后分别给他 30 秒和 1 小时去决定下一步，最后发现 30 秒和 1 小时做出的决定中，有 90% 都是一致的。 8. 不要加班，充足睡眠 💤· 作为程序员，我们可能经常加班到 9 点，到了宿舍就 10 点半，洗漱上床就 12 点了，再玩会儿手机就可以到凌晨 2、3 点。 压缩睡眠时间，大脑就得不到有效的休息，第二天的专注度就会降低，工作效率也会降低，这就是一个恶性循环。 想想我们在白天工作的时候，其实有很多时间都是被无效浪费的，如果我们给自己强制设定下班时间，创新、改变工作方式，高效率、高质量、高密度的完成工作，那是否就可以减少加班，让我们有更多的自由时间去学习新的知识技术，进而又提高我们的工作效率，形成一个正向循环。 9. 睡前 2 小时 🛌· 睡前两小时不能做的事情： 🍲 吃东西：空腹的时候会促进生长激素，生长激素可以提高血糖，消除疲劳，但如果吃东西把血糖提高了，这时候生长激素就停止分泌了 🥃 喝酒 ⛹️ 剧烈运动 💦 洗澡水温过高 🎮 视觉娱乐（打游戏，看电影等） 📺 闪亮的东西（看手机，看电脑，看电视） 💡 在灯光过于明亮的地方 适合做的事情 📖 读书 🎶 听音乐 🎨 非视觉娱乐 🧘‍♂️ 使身体放松的轻微运动 10. 周末不用刻意补觉 🚫· 很多人以周为单位进行休息，周一到周五压缩睡眠，周末再补觉，周六日一觉睡到下午 12 点，但这与工作日的睡眠节奏相冲突，造成的后果就是星期一的早上起床感的特别的厌倦、焦躁。 其实周末并不需要补觉，人体有一个以天为单位的生物钟，打破当前的生物钟周期，就会影响到下一个生物钟周期，要调节回来也需要花费一定时间。 我们应该要以天为单位进行休息，早睡早起，保持每天的专注度。","categories":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://sawr.gitee.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"有用分享","slug":"有用分享","permalink":"https://sawr.gitee.io/tags/%E6%9C%89%E7%94%A8%E5%88%86%E4%BA%AB/"}]},{"title":"Git 常用命令","slug":"tools/gitused","date":"2023-09-18T16:00:00.000Z","updated":"2024-04-10T09:13:26.816Z","comments":true,"path":"2023/09/19/tools/gitused/","link":"","permalink":"https://sawr.gitee.io/2023/09/19/tools/gitused/","excerpt":"","text":"Git 是一个分布式的版本控制系统，是目前最先进的，几乎全网程序员都在用Git来进行版本管理。 Git 特点 分布式版本控制 非常方便的对比不同版本区别 多人协作可以快速检测是否有代码冲突 使用Git前配置 设置用户名 git config --global user.name &quot;Your Name&quot; 设置邮箱 git config --global user.email &quot;email@example.com&quot; 查看 Git 配置信息 git config --list 如果想要修改配置，则只需要重新执行 1 2 两条命令即可，这些配置只需要配置一次即可。 Git 命令· git init : 初始化 , 生成 git 仓库 git add : 把文件添加到仓库(在暂存区) 可以跟的值：file.xx 某一个文件 . / -A 代表所有文件 git commit -m '提示提交的说明' : 把文件提交到仓库(提交到版本库) git status : 查看暂存区的工作状态 git reset HEAD &lt;file&gt; : 可以把暂存区的修改撤销掉（unstage），重新放回工作区 git checkout -- file : 可以丢弃工作区的修改,(可以把仓库中的文件下载到本地) git reset --hard HEAD^ : 版本回退 一个&quot;^&quot;代表一层版本 git log : 查看提交记录 运行后鼠标会悬挂，输入字母’q’退出 git reflog : 查看所有历史记录 git rm : 删除命令 Git 分支· 不在源代码上直接修改，可以开启具体相同代码的分支，在分支上进行开发，开发完成后再合并到主分支即可 git checkout -b name : 开启一个分支，并切换到这个分支下 git branch name : 开启一个分支 git checkout name : 切换分支 git branch : 查看分支 (分支前有*符号就是当前所在分支) git branch -a : 查看所有分支，包括远程 git merge : 分支合并,合并指定分支到当前分支 分支合并时的冲突 解决方案：1. 保存其中某一份 1. 全保存 git log --graph 可以看到分支合并图 git branch -d name 删除分支（记得不要在当前分支下删，会删除失败） git checkout -b [本地分支名] [origin/远程分支名] 从远程仓库拉本地不存在的分支 标签· git tag vx.x.x : 创建 git tag : 查看标签 git show &lt;tagname&gt; : 查看标签详情 远程仓库· 克隆功能 git clone git@gitee.com:gavinzhulei/vue-form-making.git 本地已经有clone下来的仓库了，需要关联远程仓库（比如公司的仓库） git remote add origin https://gitee.com/numbrun/vuepress-blog.git origin 是默认，关联多个仓库的时候可以替换别的名字，比如 company git remote -v 查看远程仓库地址 推送功能 本地向远程仓库推送代码： git push oigin develop 拉取功能 从远程仓库把代码下载到本地 : git pull company develop 标签 git push origin &lt;tagname&gt; : 向远程仓库推送 tag git push origin --tags : 一次性推送全部尚未推送到远程的本地标签 git tag -d name : 删除本地 tag git push origin :refs/tags/name To github.com:michaelliao/learngit.git :删除远程仓库中的 tag Git Stash· git stash save 能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。 git stash pop 将当前stash中的内容弹出，并应用到当前分支对应的工作目录上。 git stash list 所有保存的记录列表 git stash clear 删除所有保存 我的 Git 提交名模式· 第一种· 远程仓库有两个，一个是自己的，一个是公司的,公司的仓库是fork来的，所以你的远程仓库其实有两个 注：可通过 git remote -v 查看 步骤如下 1234567891011121314git clone 自己的仓库地址.git git remote add company 公司的仓库地址.git //写完代码 git stash save git pull company develop //先拉取公司仓库的dev分支 git stash pop // 有冲突解决冲突，解决完成后 git add . git commit -m &#39;提交的信息&#39; git push origin develop //提到自己远程的仓库的分支 //提交到自己的仓库后，在gitlab上操作-&gt;与公司仓库进行合并 这种的相对比较规范性，因为主仓库的commit会更精华简介性，因为你在本地可能有无数次的commit，会导致仓库臃肿 第二种· 远程仓库只有一个，主要通过分支管理，有一个主分支，如dev，还有其他的分支，包括属于自己的分支名，或以某个功能开发模块命名的分支等等 步骤如下 12345678910111213141516171819202122232425git clone 自己的仓库地址.git //创建分支 git checkout -b 分支名 //在编译器上发布分支 //然后在自己的分支下开发，开发完成后需要合并到dev分支上 //拉取远程最新的分支 git pull origin dev //解决冲突（此时在自己的分支名下） //解决好后，提到自己的远程分支 git push origin 分支名 //最后做合并操作，这里的合并可有至少多种方法 # 1. 命令行合并 # 来到自己的dev分支下，合并你开发的分支名 git merge 分支名 # 提交到远程仓库主分支dev git push origin dev # 1. 去gitlab做合并请求操作 通过网页端 做合并请求，可能会有审核人审核，包括权限等等问题 通过后你的代码就合并到主分支上了 常见问题· 远程新建一个分支 production-type-set ，本地没有 需要切到production-type-set 这时候直接切git checkout production-type-set是会报错的 12runnumb@h 标准版 % git checkout production-type-set error: pathspec &#39;production-type-set&#39; did not match any file(s) known to git 解决方法· 首先我们看一下远程分支情况：git branch -a 在这里没有看到我们想要的分支,先获取所有分支 git fetch 这时在切到git checkout production-type-set即可","categories":[{"name":"tools","slug":"tools","permalink":"https://sawr.gitee.io/categories/tools/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://sawr.gitee.io/tags/Git/"}]},{"title":"去郑州找对象去啦","slug":"life/20230918","date":"2023-09-17T16:00:00.000Z","updated":"2024-04-10T11:46:24.680Z","comments":true,"path":"2023/09/18/life/20230918/","link":"","permalink":"https://sawr.gitee.io/2023/09/18/life/20230918/","excerpt":"","text":"2023.9.15！出发去找女朋友啦！已经好久没有见了，异地恋终于要见面啦！ 这是我到的那天下午的天气！其实很好看，只是我 拍！呲！了！这次忘记带相机过去了！下次一定要带着相机去。 时间定格本是神技，摄影赋予了我们窥探神的技能。 乖乖的宿舍楼！看着还是很高大上！听说你们这儿的菜角很好吃！！我要尝尝怎么样，吃起来还真不错ni！（不仅仅是菜角，还有糖糕！尊都好吃。 一起玩儿蛋仔派对！我这张抓拍真的很不错！我觉得很好看！乖乖也觉得的好看。蛋仔派对的跑酷说实话很好玩儿！但是我需要多加练习才行。 这两张乍一看是一样的！但是仔细一看！居然不是一样的，怎么感觉有种找不同的感觉，亮点是！宝宝的小熊熊！这个小熊可以发出声音的！(对没错，一个玩具熊居然是可以讲话的！而且有自己的思维！！震惊🙀！) 怎么回事儿！？不信！来看视频！👇 怕听不懂！加上了字幕！ 一些合照,我的宝贝很美。 一起去了学校！吃学校的饭饭！ 2023.9.17 蜜雪冰城你真的很火！ 1497是我们的号，但是在吃完饭等了半个小时的情况下，号才叫到1350，一个中午居然可以等这么久！ 再来一句，蜜雪冰城你真的很火！ 在过了一个小时的情况下，宝宝给我安排了一杯 luckin coffee ，结果人也很多，但是这个还是先拿到的！（结果木有加糖，纯咖啡我俩都喝不惯！） 这水也太多了！我们平时都喝office的。 这里是！麻辣拌和百媚鸡的天下！ 麻辣拌是乖乖非常爱吃的！百媚鸡是我非常爱吃的！灰常好吃！ 后来给乖乖买了一些爱吃的小零食！学校里面变化很大，每次离开都会有大更新，这好像是万古不变的情况！但是能回学校还是很开心的，特别还是跟乖乖一起，喜欢学校，学校还是那么的匆忙，无论是以什么身份在学校，都能感受到最初的时光，时光荏苒，一起努力奔赴更好的生活！ 2023.9.18 开心的写完此。 wo ai ni","categories":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://sawr.gitee.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"记录生活","slug":"记录生活","permalink":"https://sawr.gitee.io/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"}]},{"title":"学习笔记：TypeScript","slug":"js/studyts","date":"2023-09-14T11:30:00.000Z","updated":"2024-04-10T09:22:18.026Z","comments":true,"path":"2023/09/14/js/studyts/","link":"","permalink":"https://sawr.gitee.io/2023/09/14/js/studyts/","excerpt":"","text":"了解TypeScript· TypeScript是由微软开发的一门开源的编程语言。 TypeScript简称TS，以JavaScript为基础构建的语言，JS有的TS都有。 Typescript = Type + JavaScript（在JS基础之上，为JS添加了类型支持）。 可以在任何支持JavaScript的平台中执行。 优点· JavaScript是弱类型的编程语言，很多的错误只有在运行的时候才会被发现，而TS在代码编译的时候（代码执行前）就可以发现错误。 支持最新的ECMAScript语法。 在代码编译阶段就能发现错误。 在JS基础上增加了类型支持。 TS和JS的区别· TypeScript JavaScript 编译期发现错误 运行时发现错误 强类型语言,支持静态和动态类型 弱类型语言，没有静态类型选项 支持模块、泛型和接口 不支持模块、泛型和接口 代码运行时会被编译成JavaScript代码，浏览器才能识别 可以直接在浏览器使用 建立TypeScript环境· 1. 安装编译TS的工具包· 1npm i -g typescript 2. 验证TS是否安装成功· 1tsc -v 3. TypeScript初体验· 创建一个TS文件，hello.ts（注意：TS文件的后缀名为 .ts），并输入以下的内容 123456function greet(name: string): string { return `hello, ${name}` } let user = &quot;Echo&quot; console.log(greet(&quot;Echo&quot;)) 将TS文件编译为JS文件，在终端中输入命令：tsc hello.ts， （此时，在同级目录中会出现一个同名的JS文件） 1234567&quot;use strict&quot;; function greet(name) { return &quot;Hello, &quot;.concat(name); } var user = &quot;Echo&quot;; console.log(greet(user)); 执行JS代码：在终端中输入命令，node hello.js，终端会输出 hello, Echo。 1&quot;hello, Echo&quot; 4. 简化运行TS的步骤· 每次修改代码后，都要重复执行两个命令，才能运行TS代码，我们可以直接使用ts-node工具包，直接在node.js中执行TS代码。 安装命令：npm i -g ts-node 使用方式：ts-node hello.ts 5. 运行TS文件的另一种方法 · 在VSCode中安装Code Runner扩展插件，在需要运行的ts文件中按鼠标右键，选择Run Code(快捷键：Ctrl+Alt+N)。 或者在VSCode窗口右上角单击小三角即可运行。 TypeScript类型注解· 1. 类型注解作用· TS类型注解的作用是为变量、函数、类等添加类型信息，用于在静态类型检查阶段检查代码的类型正确性。 2. 类型注解用途· 提供类型提示：类型注解使得开发人员可以清晰地知道变量的类型，编辑器能够根据类型注解给出相应的代码提示，提高代码的可读性和可维护性。 静态类型检查：通过给变量添加类型注解，在编译阶段可以对代码进行静态类型检查。它会检查变量的类型是否符合预期的类型，并发现潜在的类型错误。 函数参数类型检查：类型注解可以帮助开发人员在编写函数时明确参数的类型，并在调用函数时进行参数类型检查。这样可以避免因参数类型不匹配引发的潜在错误。 对象属性类型约束：通过类型注解，可以约束对象的属性类型，确保对象的属性符合特定的类型要求。 例如，上述代码中的 : number 就是类型注解。 约定变量num的类型为number（数值类型）。 3. 类型注解注意事项· 约定了什么类型，就只能给变量赋值该类型的值，否则，就会报错。 例如，我们将变量num的值123，重新赋值为字符串的“456”，此时编辑器会给出错误提示：不能将类型“string”分配给类型“number”，这些很好理解。 类型注解只在编译阶段起作用，并不会影响运行时的行为。 在编译后的 JavaScript 代码中，类型注解会被编译器忽略。 例如,编译前的TS代码: 1let num: number = 123; 编译后的JS代码: 1let num = 123; TypeScript类型· 1. TS中常用的基础类型· 我们可以将TS中常用的基础类型分为两类： JS已有的类型 TS新增的类型 JS已有的类型，我们又可以分为两类： 原始数据类型：number、string、boolean、null、undefined、symbol（ES6中的新类型）、bigint（ES10中的新类型）。 对象类型：object（包括数组、对象、函数等对象）。 TS新增的类型：any、void、自定义类型（类型别名）、联合类型、接口、元组、字面量类型、枚举等。 1.1.数值（number）· 和JS一样，TS里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TS还支持ECMAScript 2015中引入的二进制和八进制字面量。 在TS中，使用 number 来定义数值类型： 12345678910// 十进制 let decLiteral: number = 6 // 十六进制 let hexLiteral: number = 0xf00d // 二进制 let binaryLiteral: number = 0b1010 // 八进制 let octalLiteral: number = 0o744 let notANumber: number = NaN let infinityNumber: number = Infinity 编译结果： 12345678910// 十进制 var decLiteral = 6; // 十六进制 var hexLiteral = 0xf00d; // 二进制 var binaryLiteral = 10; // 八进制 var octalLiteral = 484; var notANumber = NaN; var infinityNumber = Infinity; 1.2.布尔值（boolean）· 在TS中，使用 boolean 来定义布尔值类型： 1let flag: boolean = false; 编译结果： 1var flag = false; 1.3.字符串（string）· 在TS中，使用 string 来定义字符串类型： 在TS中，字符串的表现形式主要有以下三种方式： 使用单引号（ ’ ） 使用双引号（ &quot; ） 使用模板字符串，它可以定义多行文本和内嵌表达式。这种字符串是被反引号包围（ ` ），并且以 ${ expr } 这种形式嵌入表达式 12345678let myName: string = &quot;Echo&quot; let age: number = 25 // 模板字符串 let sentence: string = `Hello, my name is ${ myName }. I&#39;ll be ${ age + 1} years old next month.` // 上面定义的sentence的语句与下面定义的sentence1语句的效果相同 let sentence1: string = &quot;Hello, my name is &quot; + myName + &quot;. I&#39;ll be &quot; + ( age + 1) +&quot; years old next month.&quot; 编译结果： 12345678var myName = &quot;Echo&quot;; var age = 25; // 模板字符串 var sentence = &quot;Hello, my name is &quot;.concat(myName, &quot;. I&#39;ll be &quot;).concat(age + 1, &quot; years old next month.&quot;); // 上面定义的sentence的语句与下面定义的sentence1语句的效果相同 var sentence1 = &quot;Hello, my name is &quot; + myName + &quot;. I&#39;ll be &quot; + (age + 1) + &quot; years old next month.&quot;; 1.4.null 和 undefined· null 和 undefined 是所有类型的子类型，默认情况下，可以把null 和 undefined赋值给其他类型。 注意：如果你将 tsconfig.json 文件中的 strictNullChecks 选项设置为 false，下面这种操作不会报错，不过尽量不要这么做。 1234567891011121314151617181920212223242526272829// 将 null 和 undefined 赋值给 string 类型 let str: string = &quot;哈哈哈&quot; str = null str = undefined // 将 null 和 undefined 赋值给 number 类型 let num: number = 123 num = null num = undefined // 将 null 和 undefined 赋值给 object 类型 let obj: object = {} obj = null obj = undefined // 将 null 和 undefined 赋值给 boolean 类型 let flag: boolean = false flag = null flag = undefined // 将 null 和 undefined 赋值给 symbol 类型 let sym: symbol = Symbol(&quot;abc&quot;) sym = null sym = undefined // 将 null 和 undefined 赋值给 bigint 类型 let big: bigint = 10n; big = null big = undefined 编译结果： 123456789101112131415161718192021222324// 将 null 和 undefined 赋值给 string 类型 var str = &quot;哈哈哈&quot;; str = null; str = undefined; // 将 null 和 undefined 赋值给 number 类型 var num = 123; num = null; num = undefined; // 将 null 和 undefined 赋值给 object 类型 var obj = {}; obj = null; obj = undefined; // 将 null 和 undefined 赋值给 boolean 类型 var flag = false; flag = null; flag = undefined; // 将 null 和 undefined 赋值给 symbol 类型 var sym = Symbol(&quot;abc&quot;); sym = null; sym = undefined; // 将 null 和 undefined 赋值给 bigint 类型 var big = 10n; big = null; big = undefined; 注意：如果你在 tsconfig.json 文件中指定了“strictNullChecks：true”，null 和 undefined 只能赋值给 void 和它们各自的类型。 1.5.symbol· symbol 是ES6新增的一种基本数据类型，Symbol()函数 会返回 symbol 类型的值，每个从 Symbol()函数 返回的 symbol 的值都是唯一的。 123const sym1: symbol = Symbol() const sym2: symbol = Symbol(&#39;temp&#39;) const sym3: symbol = Symbol(&#39;temp&#39;) 上面的代码创建了三个新的 symbol 类型，但是注意的是，每个从 Symbol()函数 返回的值都是唯一的。 此时，如果我们在控制台打印下面的代码，两者并不相等。 1console.log(sym2 === sym3) // false 1.6.bigint· bigint 是ES10新增的一种基本数据类型，在JS中，可以用 Number 表示的最大整数为 2^53 - 1，可以写为 Number.MAX_SAFE_INTEGER。如果超过了这个界限，那么就可以用 BigInt 来表示，它可以表示任意大的整数。 在一个整数字面量后面加 n 的方式定义一个 bigint，或者调用函数 BigInt()。 1234let big1: bigint = 10n let big2: bigint = BigInt(10) console.log(big1 === big2) // true 1.7.区别· 1.7.1. null 和 undefined 的区别· 在JS中，null 表示“什么都没有”，而 undefined 是一个没有设置值的变量 用 typeof 检测 null，返回 object；typeof 一个没有值的变量会返回 undefined null 是一个只有一个值的特殊类型，表示一个空对象的引用 null 和 undefined 是其它任何类型（包括void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。而在TS中启用严格的空校验（strictNullChecks）特性，就可以使得 null 和 undefined 只能被赋值给 void 或本身对应的类型 1.7.2. bigint 和 number 的区别· number 和 bigint 都可以表示数字，但是两者不能进行相互转换 仅在值大于 2^53 - 1时，才使用 bigint，否则尽量使用 number 用 typeof 检测 bigint 对象时，返回 bigint，用 typeof 检测 number，返回 number 1234console.log(typeof 10) // number console.log(typeof Number(10)) // number console.log(typeof 10n) // bigint console.log(typeof BigInt(10)) // bigint","categories":[{"name":"前端","slug":"前端","permalink":"https://sawr.gitee.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sawr.gitee.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://sawr.gitee.io/tags/TypeScript/"}]},{"title":"开发包管理国内镜像源","slug":"tools/jingxiangyua","date":"2023-09-05T10:00:00.000Z","updated":"2024-04-10T09:00:26.356Z","comments":true,"path":"2023/09/05/tools/jingxiangyua/","link":"","permalink":"https://sawr.gitee.io/2023/09/05/tools/jingxiangyua/","excerpt":"","text":"使用包管理可以大大降低引用和管理第三方库的成本，但是很多源都在国外，通过包管理安装的时候，容易超时；我们可以通过修改为国内源，或者使用代理来解决这个问题。 提供Pip、Composer、NPM、Gem、Maven国内源地址。 Pip· 提供方 源地址 豆瓣 pip install -i https://pypi.doubanio.com/simple/ 清华大学 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 阿里云 pip install -i https://mirrors.aliyun.com/pypi/simple/ Maven· 提供方：阿里云 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;settings xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd&quot; xmlns=&quot;http://maven.apache.org/SETTINGS/1.1.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Repository Switchboard&lt;/name&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;id&gt;offical&lt;/id&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;offical&lt;/activeProfile&gt; &lt;/activeProfiles&gt; &lt;/settings&gt; Composer· 提供方 源地址 阿里云 composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ 华为云 composer config -g repo.packagist composer https://mirrors.huaweicloud.com/repository/php/ 上海交通大学 composer config -g repo.packagist composer https://packagist.mirrors.sjtug.sjtu.edu.cn composer config -g repo.packagist composer https://packagist.jp NPM· 提供方 源地址 淘宝 npm config set registry https://registry.npmmirror.com 淘宝 pnpm config set registry https://registry.npmmirror.com 淘宝 yarn config set registry https://registry.npmmirror.com npm config set registry http://r.cnpmjs.org/ pnpm config set registry http://r.cnpmjs.org/ yarn config set registry http://r.cnpmjs.org/ Gem· 提供方 源地址 Ruby China gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ 清华大学 gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/ 代理方式· 包管理器 代理方式 使用方式 pip http/https https_proxy=http://ip:hort pip install composer http/https https_proxy=http://ip:hort composer install npm http/https npm config set proxy http://ip:port npm config set https-proxy https://ip:port yarn config set proxy http://ip:port yarn config set https-proxy https://ip:port gem http/https http_proxy=http://ip:host https_proxy=https://ip:host gem install go http/https http_proxy=http://ip:host https_proxy=https://ip:host go get","categories":[{"name":"tools","slug":"tools","permalink":"https://sawr.gitee.io/categories/tools/"}],"tags":[{"name":"镜像源","slug":"镜像源","permalink":"https://sawr.gitee.io/tags/%E9%95%9C%E5%83%8F%E6%BA%90/"}]},{"title":"MySQL基础语法","slug":"mysql/teach","date":"2023-09-03T16:00:00.000Z","updated":"2024-04-10T09:00:26.358Z","comments":true,"path":"2023/09/04/mysql/teach/","link":"","permalink":"https://sawr.gitee.io/2023/09/04/mysql/teach/","excerpt":"","text":"MySQL作为一个常用的关系型数据库，其语法也是比较简单，但是知识点较多，所以为了巩固记忆，写此文章，方便复习。本文直接上干货，历史之类的就不过多介绍。 数据库的类型· MySQL数据库存储数据时，不同的数据类型决定了 MySQL存储数据方式的不同。为此，MySQL数据库提供了多种数据类型，其中包括整数类型、浮点数类型、定点 数类型、日期和时间类型、字符串类型、二进制…等等数据类型。 1.整数类型· 数据类型 字节数 无符号数的取值范围 有符号数的取值范围 TINYINT 1 0~255 -128~127 SMALLINT 2 0~65535 -32768~32768 MEDIUMINT 3 0~16777215 -8388608~8388608 INT 4 0~4294967295 -2147483648~ 2147483648 BIGINT 8 0~18446744073709551615 -9223372036854775808~9223372036854775808 2.浮点数类型和定点数类型· 在MySQL数据库中使用浮点数和定点数来存储小数。 浮点数的类型有两种： 单精度浮点数类型：FLOAT 双精度浮点数类型：DOUBLE 定点数类型：DECIMAL（M,D） DECIMAL类型的有效取值范围是由M和D决定的。其中，M表示的是数据的长 度，D表示的是小数点后的长度。比如，将数据类型为DECIMAL(10,2)的数据10.54321 插人数据库后显示的结果为10.54. 3.字符串类型· 表示字符串的类型有两种： CHAR：当数据为CHAR(M)类型时，不管插入值的长度是实际是多少它所占用的存储空间都是M个字节。 VARCHAR：VARCHAR(M)所对应的数据为所占用的字节数为实际长度加1 例如： 插入值 CHAR(3) 存储需求 VARCHAR(3) 存储需求 ‘’ ‘’ 3个字节 ‘’ 1个字节 ‘a’ ‘a’ 3个字节 ‘a’ 2个字节 ‘ab’ ‘ab’ 3个字节 ‘ab’ 3个字节 ‘abc’ ‘ab’ 3个字节 ‘abc’ 4个字节 ‘abcd’ ‘ab’ 3个字节 ‘abc’ 4字节 4.文本类型· 文本类型用于表示大文本数据，例如，文章内容、评论、详情等，它的类型分为如下4种： 数据类型 储存范围 TINYTEXT 0~255字节 TEXT 0~65535字节 MEDIUMTEXT 0~16777215字节 LONGTEXT 0~4294967295字节 5.日期与时间类型· MySQL提供的表示日期和时间的数据类型分别是： YEAR：表示年份，日期格式：YYYY，取值范围是1901~2155 DATE：表示日期和时间，显示形式为：YYYY-MM-DD，取值范围：1000-01-01~9999-12-31 TIME：表示日期和时间，显示形式为：HH:MM:SS,HH表示小时，MM表示分钟，SS表示秒，使用CURRENT_TIME或NOW()输人当前系统时间。 DATETIME：表示日期和时间，它的显示形式为YYYY-MM-DD HH: MM:SS，使用NOW来输人当前系统的日期和时间。 TIMESTAMP：表示日期和时间，它的显示形式与DATETIME相同但取值范围比DATETIME小。 使用CURRENT_TIMESTAMP输人系统当前日期和时间。 输人NULL时系统会输人系统当前日期和时间。 无任何输人时系统会输入系统当前日期和时间。 6.二进制类型· 在MySQL中常用BLOB存储二进制类型的数据，例如：图片、PDF文档等。BLOB类型分为如下四种： 数据类型 储存范围 TINYBLOB 0~255字节 BLOB 0~65535字节 MEDIUMBLOB 0~16777215字节 LONGBLOB 0~4294967295字节 数据库、表的基本操作· 1、数据库· 创建数据库： 1create database 数据库名称; 查看数据库基本信息： 1show create database 数据库名称; 删除数据库： 1drop database 数据库名称; 修改数据库字符集： 1alter database db1 character set gbk; 使用数据库 or 切换数据库 1use db1; 2.数据表的基本操作· 创建完数据库后一般来说就是要开始创建表来存储数据了。 PS：如果你使用的是命令行来操作MySQL的话，在创建表前请使用USE 数据库名; 来指定是在哪个数据库中进行操作，否则会抛出错误。 创建表： 123456create table 表名( 字段1 字段类型, 字段2 字段类型, … 字段n 字段类型 ); 例如：创建一个学生表 123456create table student( id int, name varchar(20), gender varchar(10), birthday date ); 查看表基本信息（查看建表SQL语句）： 1show create table student; 查看表的字段信息： 1desc student; 3.修改数据表· 修改表名： 1alter table student rename to stu; 修改字段名 MySQL命令： 1alter table stu modify sname int; 增加字段 MySQL命令： 1alter table stu add address varchar(50); 删除字段 MySQL命令： 1alter table stu drop address; 删除数据表: 1drop table 表名; 2023.9.4 20:46 写到这里，听会歌喝口水休息一会儿。 数据库的约束· 约束条件其实就是限制一些不是表需要的数据插入到表中去，保护数据库中的数据是唯一的，可以理解为限制条件，下面列举了常用的约束条件。 约束条件 说明 PRIMARY KEY 主键约束用于唯一标识对应的记录 FOREIGN KEY 外键约束 NOT NULL 非空约束 UNIQUE 唯一性约束 DEFAULT 默认值约束，用于设置字段的默认值 1.主键约束· 主键约束即primary key用于唯一的标识表中的每一行。被标识为主键的数据在表中是唯一的且其值不能为空。这点类似于我们每个人都有一个身份证号，并且这个身份证号是唯一的。主键约束基本语法： 1字段名 数据类型 primary key; 创建表的时候添加主键： 1234create table student( id int primary key, name varchar(20) ); or 12345create table student01( id int, name varchar(20), primary key(id) ); 2.非空约束· 所谓非空约束，就是让字段的值不能是空的。 1字段名 数据类型 NOT NULL; example： 12345create table student02( id int, name varchar(20) not null, sex int not null ); 3.默认值约束· 默认值约束就是给字段添加一个默认值。 1字段名 数据类型 DEFAULT 默认值； 4.唯一性约束· 唯一性约束是用UNIQUE，用于保证数据表中字段的唯一性，表中字段的值不能重复出现。 1字段名 数据类型 UNIQUE; 5.外键约束 · 外键约束即FOREIGN KEY常用于多张表之间的约束。 1234-- 在创建数据表时语法如下： CONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段) -- 将创建数据表创号后语法如下： ALTER TABLE 从表名 ADD CONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段); exmaple: 创建一个学生表 MySQL命令： 1234create table student05( id int primary key, name varchar(20) ); 创建一个班级表 MySQL命令： 1234create table class( classid int primary key, studentid int ); 学生表作为主表，班级表作为副表设置外键， MySQL命令： 1alter table class add constraint fk_class_studentid foreign key(studentid) references student05(id); 删除外键 语法如下： 1alter table 从表名 drop foreign key 外键名； 示例：删除外键 MySQL命令： 1alter table class drop foreign key fk_class_studentid; 外键约束需要注意的细节： 1、从表里的外键通常为主表的主键 2、从表里外键的数据类型必须与主表中主键的数据类型一致 3、主表发生变化时应注意主表与从表的数据一致性问题 增删改查· 数据库的增删改查是指对数据库中的记录进行增加、删除、修改和查询的操作。其中，增加操作包括INSERT语句，删除操作包括DELETE语句，修改操作包括UPDATE语句，查询操作包括SELECT语句。 INSERT 插入· MySQL中的插入语句用于向数据库表中添加新记录。INSERT INTO语句的语法如下： 12INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...); 其中，table_name是要插入数据的表名，column1、column2、column3等是表中的列名，value1、value2、value3等是要插入的数据值。 假设我们有一个名为students的表，其中包含id、name和age三个列，我们要向其中插入一条新记录，可以使用以下语句： 1INSERT INTO students (id, name, age) VALUES (1, &#39;张三&#39;, 18); 同时插入多条数据： 1234INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...), (value4, value5, value6, ...), (value7, value8, value9, ...); DELETE 删除· MySQL中的删除语句用于从数据表中删除记录。可以使用以下语法： 1DELETE FROM 表名 [WHERE 条件表达式]; example: 删除所有age等于14的数据： 1delete from student where age=14; 删除全部数据： 1234DELETE FROM 表名; -- 例如：删除学生表 DELETE FROM student; TRUNCATE和DELETE都是MySQL中删除数据的语句，但是它们之间有一些区别。 TRUNCATE是删除表中的所有数据，但不删除表结构，速度比DELETE快。DELETE可以带WHERE子句，条件删除；而TRUNCATE只能删除整个表。 DELETE是可以恢复删除的数据，而TRUNCATE和DROP不能恢复删除的数据。 执行速度方面，DROP &gt; TRUNCATE &gt;&gt; DELETE。 UPDATE 更新· 用于更新字段中的内容。 1UPDATE 表名 SET 字段名1 = 值1[,字段名2 =值2,…] [WHERE 条件表达式]; 字段名1、字段名2…用于指定要更新的字段名称；值1、值 2…用于表示字段的新数据；WHERE 条件表达式 是可选的，它用于指定更新数据需要满足的条件。 example： 将name为tom的记录的age设置为20并将其gender设置为female 1update student set age=20,gender=&#39;female&#39; where name=&#39;tom&#39;; 将所有记录的age设置为18 1update student set age=18; 2023.9.4 21:27 今天先不写了，去背会儿单词。 数据表查询 · 1.简单查询· 我们新建立了一个数据表 123456CREATE TABLE student ( sid CHAR(6), sname VARCHAR(50), age INT, gender VARCHAR(50) DEFAULT &#39;male&#39; ); 查询表中所有字段：· 1select * from student; 查询指定字段（sid，sname）· 1select sid,sname from student; 常数查询：· example：在后面加上查询日期 1select sid,sname,&#39;2023-09-05&#39; from student; 结果会在最后一列每一行都增加日期。 从查询结果中过滤重复数据· 1select distinct gender from student; 查询前加上 distinct 即可。 算术运算符· 在SELECT查询语句中可以使用加减乘除运算符。 1select sname,age+10 from student; 2.聚合函数· 有些公司会有这种需求：统计某个字段的最大值、最小值、 平均值等等。 为了简化操作，MySQL为我们提供了聚合函数来实现这些操作。 聚合函数意思为把多行的数据变为一行。 count()· 统计表中数据的行数或者统计指定列其值不为NULL的数据个数 查询学生总数： 1select count(*) from student; max()· 计算指定列的最大值，如果指定列是字符串类型则使用字符串排序运算 查询年龄最大学生： 1select sname,max(age) from student; min()· 计算指定列的最小值，如果指定列是字符串类型则使用字符串排序运算 查询年龄最小学生： 1select sname,min(age) from student; sum()· 计算指定列的数值和，如果指定列类型不是数值类型则计算结果为0 查询表中所有学生年龄总和： 1select sum(age) from student; avg（）· 计算指定列的平均值，如果指定列类型不是数值类型则计算结果为0 查询学生平均年龄： 1select avg(age) from student; 3.时间函数· 可自行测试： 123456789101112131415SELECT NOW(); SELECT DAY (NOW()); SELECT DATE (NOW()); SELECT TIME (NOW()); SELECT YEAR (NOW()); SELECT MONTH (NOW()); SELECT CURRENT_DATE(); SELECT CURRENT_TIME(); SELECT CURRENT_TIMESTAMP(); SELECT ADDTIME(&#39;14:23:12&#39;,&#39;01:02:01&#39;); SELECT DATE_ADD(NOW(),INTERVAL 1 DAY); SELECT DATE_ADD(NOW(),INTERVAL 1 MONTH); SELECT DATE_SUB(NOW(),INTERVAL 1 DAY); SELECT DATE_SUB(NOW(),INTERVAL 1 MONTH); SELECT DATEDIFF(&#39;2019-07-22&#39;,&#39;2019-05-05&#39;); 4.字符串函数· 12345678--连接函数 SELECT CONCAT () --查看字符串第一次出现位置 SELECT INSTR (); --统计长度 SELECT LENGTH(); CONCAT()函数：这个函数用于连接两个或更多的字符串。 其基本语法是 CONCAT(string1, string2, …, string_n)，其中string1、string2等为要连接的字符串。 例如：SELECT CONCAT('Hello', ' ', 'World'); 将返回 “Hello World”。 INSTR()函数：这个函数用于返回子字符串在字符串中第一次出现的位置。 如果子字符串不存在于字符串中，则返回0。其基本语法是 INSTR(string, substring)，其中string是要搜索的字符串，substring是要查找的子字符串。 例如：SELECT INSTR('Hello World!', 'World'); 将返回 7，因为 “World” 在 “Hello World!” 中第一次出现的位置是 7。 LENGTH()函数：这个函数用于返回字符串的长度（字符数）。 其基本语法是 LENGTH(string)，其中string是要计算长度的字符串。 例如：SELECT LENGTH('Hello World!'); 将返回 12，因为 “Hello World!” 包含 12 个字符。 5.数学函数· 123456-- 绝对值 SELECT ABS(-136); -- 向下取整 SELECT FLOOR(3.14); -- 向上取整 SELECT CEILING(3.14); 条件查询· 数据库中存有大量数据，我们可根据需求获取指定的数据。此时，我们可在查询语句中通过WHERE子句指定查询条件对查询结果进行过滤。 关系运算符· 在WHERE中可使用关系运算符进行条件查询 关系运算符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 查询年龄等于或大于17的学生的信息 MySQL命令： 1select * from student where age&gt;=17; IN关键字查询· IN关键字用于判断某个字段的值是否在指定集合中。如果字段的值恰好在指定的集合中，则将字段所在的记录将査询出来。 查询sid为S_1002和S_1003的学生信息 MySQL命令： 1select * from student where sid in (&#39;S_1002&#39;,&#39;S_1003&#39;); 查询sid为S_1001以外的学生的信息 MySQL命令： 1select * from student where sid not in (&#39;S_1001&#39;); BETWEEN AND关键字查询· BETWEEN AND用于判断某个字段的值是否在指定的范围之内。如果字段的值在指定范围内，则将所在的记录将查询出来 查询15到18岁的学生信息 MySQL命令： 1select * from student where age between 15 and 18; 查询不是15到18岁的学生信息 MySQL命令： 1select * from student where age not between 15 and 18; 使用空值查询· 在MySQL中，使用 IS NULL关键字判断字段的值是否为空值。请注意：空值NULL不同于0，也不同于空字符串 查询sname不为空值的学生信息 MySQL命令： 1select * from student where sname is not null; 使用AND关键字查询· 在MySQL中可使用AND关键字可以连接两个或者多个查询条件。 查询年纪大于15且性别为male的学生信息 MySQL命令： 1select * from student where age&gt;15 and gender=&#39;male&#39;; 使用OR关键字查询· 在使用SELECT语句查询数据时可使用OR关键字连接多个査询条件。在使用OR关键字时，只要记录满足其中任意一个条件就会被查询出来 查询年纪大于15或者性别为male的学生信息 MySQL命令： 1select * from student where age&gt;15 or gender=&#39;male&#39;; 使用LIKE关键字查询· LIKE通常与%（表示任意多个字符）和_（表示一个字符）通配符一起使用,可以判断两个字符串是否相匹配。 查询所有以&quot;张&quot;开头的姓名： 1sql SELECT * FROM users WHERE name LIKE &#39;张%&#39;; 查询名字中包含&quot;小&quot;的所有用户： 1SELECT * FROM users WHERE name LIKE &#39;%小%&#39;; 查询名字长度为3个字符的所有用户： 1SELECT * FROM users WHERE name LIKE &#39;___&#39;; 查询电话号码以&quot;138&quot;开头的所有用户： 1SELECT * FROM users WHERE phone LIKE &#39;138%&#39;; 请注意，LIKE操作符对大小写敏感。如果需要进行不区分大小写的搜索，可以使用LOWER()或UPPER()函数将列值和搜索模式转换为相同的大小写，例如： 1SELECT * FROM users WHERE LOWER(name) LIKE &#39;%张%&#39;; 使用LIMIT限制查询结果的数量· 当执行查询数据时可能会返回很多条记录，而用户需要的数据可能只是其中的一条或者几条 查询学生表中年纪最小的3位同学 MySQL命令： 1select * from student order by age asc limit 3; 使用GROUP BY进行分组查询· 将表中的数据进行分组，再进行查询等操作。可以理解为通过GROUP BY将原来的表拆分成了几张小表。 GROUP BY和聚合函数一起使用· 统计各部门员工个数 MySQL命令： 1select count(*), departmentnumber from employee group by departmentnumber; 统计部门编号大于1001的各部门员工个数 MySQL命令： 1select count(*), departmentnumber from employee where departmentnumber&gt;1001 group by departmentnumber; GROUP BY和聚合函数以及HAVING一起使用· 统计工资总和大于8000的部门 MySQL命令： 1select sum(salary),departmentnumber from employee group by departmentnumber having sum(salary)&gt;8000; 使用ORDER BY对查询结果排序· 从表中査询出来的数据可能是无序的或者其排列顺序不是我们期望的。为此，我们可以使用ORDER BY对查询结果进行排序 其语法格式如下所示： 123SELECT 字段名1,字段名2,… FROM 表名 ORDER BY 字段名1 [ASC 丨 DESC],字段名2 [ASC | DESC]; 在该语法中：字段名1、字段名2是查询结果排序的依据；参数 ASC表示按照升序排序，DESC表示按照降序排序；默认情况下，按照ASC方式排序。通常情况下，ORDER BY子句位于整个SELECT语句的末尾。 查询所有学生并按照年纪大小升序排列 MySQL命令： 1select * from student order by age asc; 查询所有学生并按照年纪大小降序排列 MySQL命令： 1select * from student order by age desc; 表别名· 在字段名后加一个as即可更名，或者不加也可以直接加一个空格。 1select name as &#39;姓名&#39;,id from student; 2023.9.5 11:23 记录此刻。","categories":[{"name":"后端","slug":"后端","permalink":"https://sawr.gitee.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://sawr.gitee.io/tags/MySQL/"}]},{"title":"Markdown 入门到精通","slug":"tools/markdown","date":"2023-08-29T05:42:00.000Z","updated":"2024-04-10T09:28:31.311Z","comments":true,"path":"2023/08/29/tools/markdown/","link":"","permalink":"https://sawr.gitee.io/2023/08/29/tools/markdown/","excerpt":"","text":"之前图床服务出现问题导致图片无法加载，请见谅。 现在大多数帮助文档以及论坛都是由Markdown作为基础来编写的，Markdown有轻量化、易读写的特性，并且对图片、图表以及数学公式都有支持，语法特别简单，而且排版贼好，不像word那样动不动就出错，官方网站的教程不是很清楚明了，所以打算写这篇文章。 这个笔记的作用是记录学习的过程，另外就是忘了还可以拿来复习。 Markdown 简单说明· Markdown几乎是目前互联网上最流行的写作语言。 Markdown编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown学习成本低，常用的语法很少，只有几种符号，简单易学快速上手。 例如： GitHub、CSDN、简书、掘金、博客园、知乎等。 Markdown 工具· Markdown常用的编写工具有Typora(收费)、VSCode(免费)、Obsidian(免费)等工具，整体结构都差不多，Typora属于用户是最多的，后面我会写一个关于Typora的破解教程。 Markdown 语法· 标题· 标题使用#号标记，可以表示1-6级标题， 随#的个数递增，一级标题字号最大，六级标题字号最小。 代码如下： 123456# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 效果： PS：#字符要加一个空格后在输入标题 标题应该置于行首，如果放入表格中可能无法正确解析 字体· 星号与下划线都可以，单是斜体，双是粗体，三是粗斜体 代码 效果 *这是斜体* 这是斜体 _这是斜体_ 这是斜体 **这是粗体** 这是粗体 __这是粗体__ 这是粗体 ***这是粗斜体*** 这是粗斜体 ___这是粗斜体___ 这是粗斜体 PS：加粗Ctrl+B 斜体Ctrl+I 列表· 无序列表：使用星号 * 、加号 + 或减号 - ，效果一致 有序列表：使用数字 1、2、3 等，并加上英文句号 . 1234567* 无序列表 1 + 无序列表 2 - 无序列表 3 1. 有序列表 1 2. 有序列表 2 3. 有序列表 3 效果： 无序列表 1 无序列表 2 无序列表 3 有序列表 1 有序列表 2 有序列表 3 控制层级：符号星号 * 、加号 + 或减号 - 前使用 tab 1234* 无序列表 1 + 无序列表 2 - 无序列表 2.1 * 无序列表 2.2 效果： 无序列表 1 无序列表 2 无序列表 2.1 无序列表 2.2 链接 / 图片链接· 原始链接：&lt;链接地址&gt; 文字链接：[链接名称] (链接地址) 12原始链接：&lt;https://sawr.gitee.io&gt; 文字链接：[奥奥の探索日记](https://sawr.gitee.io/) 效果： 原始链接：https://sawr.gitee.io 文字链接：奥奥の探索日记 图片· 图片链接：！[链接名称] (链接地址 “title”) 1![神奇的图片名字](https://tucdn.wpon.cn/2023/08/29/ab1ebc2d0c3f4.jpg) 效果： 复制的图片直接Ctrl+V粘贴过来更为快捷。 引用· 一层引用：一个右尖括号 &gt; 二层引用：两个右尖括号 &gt; N 层引用：N 个右尖括号 &gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 一层引用 &gt; 二层引用 &gt;&gt; 三层引用 ``` 效果： 一层引用 &gt; 二层引用 &gt;&gt; 三层引用 --- ### 分隔线 - 【三个以上】星 * 或减号 - ```html --- *** * * **** - - - ---- ``` 效果： --- *** * * **** - - - ---- ### 删除线 - 删除文字前后添加【两个】~ ```html ~~我是一个很可怜不幸被删除的文字~~ ``` 效果： ~~我是一个很可怜不幸被删除的文字~~ ### 下划线 - 下划线文字前后添加&lt; u &gt;&lt; u /&gt; - 下划线使用了HTML中的标签 ```html &lt;u&gt;我是一个带有下划线的文字&lt;/u 效果： 我是一个带有下划线的文字 表格· 分隔列：使用竖线 | 分隔行：使用减号 - 对齐位置：冒号 : 位置决定对齐位置 左对齐：:- 右对齐：-: 居中对齐：:-: 123456单词 | 音标 | 翻译 :- | :-: | -: |aunt|/eɪnt/|姨母；姨母 姑母；伯母；婶母| |brother|/brʌðər/|兄；弟| |cousin|/ˈkʌzən/|堂（表）兄弟；堂（表）姐妹| |couple|/ˈkʌpl/|夫妇| 单词 音标 翻译 aunt /eɪnt/ 姨母；姨母 姑母；伯母；婶母 brother /brʌðər/ 兄；弟 cousin /ˈkʌzən/ 堂（表）兄弟；堂（表）姐妹 couple /ˈkʌpl/ 夫妇 上表格中 :- | :-: | -: 分别表示 第一列左对齐，第二列剧中，第三列右对齐，所以可能会有一些怪异，仅仅演示效果。 脚注· 脚注：文本右上角备注 尾注：文末备注内容 脚注：文本[^注脚名字] 尾注：[^数字]:文本解释 12345微软[^1] [^1]: 微软（Microsoft）是一家跨国电脑科技公司，成立于 1975 年，由比尔·盖茨和保罗·艾伦创立。 GitHub[^2] [^2]:https://www.github.com/ 效果：暂不支持。 微软[1] GitHub[2] 代码· 行内代码：内容前后【一个】反引号 ` 1一个著名的搜索引擎：`www.baidu.com` 效果： 一个著名的搜索引擎：www.baidu.com 块内代码：内容前后【三个】反引号**12345678910- 在首行\\`\\`\\`后加上编程语言 如`js` ```js // 定义一个函数，用于输出 \"Hello, World!\" function sayHello() { console.log(\"Hello, World!\"); } // 调用 sayHello 函数 sayHello(); Markdown 高级语法· 插入目录· 输入内容[TOC]即可出现目录，例如： [TOC] HTML语法· Markdown支持原生HTML语法，通过内联样式书写即可。 文字效果： 1&lt;h2 style=&#39;text-shadow: 10px 5px 5px red&#39;&gt;你好呀，欢迎来学习&lt;/h2&gt; 你好呀，欢迎来学习 一个圆角正方形 1&lt;div style=&#39;border:1px solid green;width:130px;height:130px;border-radius:30px;background:black;&#39;/&gt; 表格 1234567891011121314151617&lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;课程表&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;th&gt;星期四&lt;/th&gt; &lt;th&gt;星期五&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;语文&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;英语&lt;/td&gt; &lt;td&gt;英语&lt;/td&gt; &lt;td&gt;英语&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 课程表 星期一 星期二 星期三 星期四 星期五 语文 数学 英语 英语 英语 复选框· Markdown也支持写待办任务事项，语法也是特别简单 TODOLIST ： - [x/X] 和 - [ ] 12- [x] 表示选中状态 - [ ] 表示未选中状态 [x] 表示选中状态 [ ] 表示未选中状态 数学公式· $$表示一整行的公式 12$ax + b = 0$ $a² + b² = c²$ 例如： 名称 公式 解释 二元一次方程 $ax + b = 0$ 这是一个含有两个未知数 x 和 y 的一次方程。 勾股定理 $a² + b² = c²$ 勾股定理描述了直角三角形的三边长度关系。 流程图· 代码属性是mermaid,使用时添加上即可，测试为了方便所以采用了json格式显示。 例子： 12345graph TD; A(爷爷)--&gt;B(爸爸); A--&gt;C(叔叔); B--&gt;D(大郎); B--&gt;E(二郎); 时序图· 代码属性是mermaid,使用时添加上即可，测试为了方便所以采用了json格式显示。 效果： 12345graph LR; A(爷爷)--&gt;B(爸爸); A--&gt;C(叔叔); B--&gt;D(大郎); B--&gt;E(二郎); 结语· 这篇文章，写了整整一个下午，内容全为干货，最快的时间来上手Markdown。 如果有没写到的，欢迎补充。 有些功能没有展示出来，是因为有些技术难关还没有攻克，等待攻克技术难关了就可以显示了。 一起学习，一起努力。 微软（Microsoft）是一家跨国电脑科技公司，成立于 1975 年，由比尔·盖茨和保罗·艾伦创立。 ↩︎ https://www.github.com/ ↩︎","categories":[{"name":"tools","slug":"tools","permalink":"https://sawr.gitee.io/categories/tools/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://sawr.gitee.io/tags/Markdown/"}]},{"title":"常见单词分类背","slug":"english/changjiandanci","date":"2023-08-26T16:00:00.000Z","updated":"2024-04-10T09:08:28.651Z","comments":true,"path":"2023/08/27/english/changjiandanci/","link":"","permalink":"https://sawr.gitee.io/2023/08/27/english/changjiandanci/","excerpt":"","text":"这里是详细的划分了一些常见的单词，方便进行记忆。 音标添加工作量巨大，所以没有音标的单词，会慢慢的更新添加上。 请每天努力背单词！ 家庭与人物称呼、职业职务· 1家庭人员· 单词 音标 翻译 aunt /eɪnt/ 姨母；姨母 姑母；伯母；婶母 brother /brʌðər/ 兄；弟 cousin /ˈkʌzən/ 堂（表）兄弟；堂（表）姐妹 couple /ˈkʌpl/ 夫妇 dad /dæd/ 爸爸 daughter /ˈdɔːtər/ 女儿 family /ˈfæmɪli/ 家；家庭；家人；亲属；家族 father /ˈfɑːðər/ 爸爸；父亲 grandchild /ˈgrændˌtʃaɪld/ 孙子/女，外孙子/孙女 granddaughter /ˈgrændˌdɔːtər/ 孙女，外孙女 grandfather /ˈgrændˌfɑːðər/ 祖父；外祖父 grandma /ˈgrændmɑː/ （口）奶奶；外婆 grandmother /ˈgrændˈmʌðər/ 祖母；外祖母 grandpa /ˈgrændˈpɑː/ （口）爷爷；外公 grandparent /ˈgrændˌpɑːrənt/ 祖父母；外祖父母 grandson /ˈgrændˈsʌn/ 孙子，外孙子 granny /ˈgræn妮/ 老奶奶 husband /ˈhʌzbənd/ 丈夫 mom /mɑːm/ 妈妈 mother /ˈmʌðər/ 母亲；妈妈 parent /ˈpærənt/ 父母亲 relation /rɪˈleɪʃən/ 关系；亲属关系 sister /ˈsɪstər/ 姐；妹 son /sɒn/ 儿子 uncle /ˈʌŋkəl/ 叔；伯；舅；姨夫；姑夫 wife /waɪf/ （pl. wives）妻子 2人物称呼· 单词 音标 翻译 adult /ˈædʌlt/ 成年人 Asian /ˈeɪʃən/ 亚洲人；亚洲的adj. baby /ˈbeɪbɪ/ 婴儿；小孩 boy /ˈbɔɪ/ 男孩 child /ˈtʃaɪld/ 孩子 classmate /ˈklæsˌmɛndər/ 同班同学 elder /ˈeldər/ 长者；前辈 enemy /ˈenɪmli/ 敌人 European /ˌjʊrəˈpiːənən/ 欧洲人；欧洲的adj. fan /fæn/ 迷（热情崇拜者）；扇 foreigner /ˈfrɒndərlər/ 外国人 gentleman /ˈvɪntərn(ə)l/ 绅士 girl /ɡɜːrl/ 女孩 friend /frend/ 朋友 god /ɡod/ 神；（God）上帝 guest /ɡest/ 客人，来宾 hero /ˈhɪər/ 英雄 human /hjuːmən/ 人类 kid /kɪd/ 小孩 lady /ˈleɪdi/ 女士，夫人 madam /ˈmædəm/ 夫人，女士 man /mæn/ 成年男人；人，人类 member /ˈmɛmbənt/ 成员，会员 Miss /miːs/ 小姐，女士 Mr. ( mister) /ˌmɪstər/ 先生 Mrs. (mistress) /ˈmɛstriːs/ 夫人，太太（称呼已婚妇女） Ms. /ˈmɪsɪz/ 女士（用于婚姻状况不明的女子姓名前） neighbor /ˈneɪbər/ 邻居 nobody /ˈnʌðəri/ 渺小人物 officer /ˈɒffɪsənt/ 军官，警官；官员，高级职员 owner /ˈɑːswɜːrt/ 所有者；业主 patient /ˈpeɪʃənt/ 病人，患者 person /ˈpɜːrsnl̩/ 人；人们 pioneer /ˈpaɪəˌsaɪənt/ 先锋，开拓者 passenger /ˈpæspəndər/ 乘客，旅客 people /ˈpiːpl/ 人；人们 person /ˈpɜːrsnl̩/ 人；人们 3职业职务· 单词 音标 翻译 boss /bɒs/ 老板 captain /ˈkæptɪnər/ 船长，队长 chairman/woman /ˈtʃeəndɪ/ 主席 coach /kəʊtʃ/ 教练； cook /kuːk/ 厨师 dentist /ˈdɛntɪst/ 牙医 director /ˌdɪrektəˈreɪn(d) 主管，负责人 doctor /ˈdɒktər/ 医生 driver /draɪvər/ 驾驶员；司机 engineer /ˌenɪɡˈraɪn(d) 工程师 farmer /fɑːmər/ 农民 fisherman /ˈfiʃərmən/ 渔民；渔夫（pl. fishermen） guard /gɑːrd/ 看守，卫兵 king /kɪŋ/ 国王 leader /ˈliːdər/ 领导者；指挥者 manager /ˈmænɪdʒər/ 经理，管理人 monitor /ˈmɒnɪtər/ (班级内的)班长，纠察生； nurse /ˈnɜːrsɪ/ 护士，保育员 officer /ˌɒfɪˈziʃən/ 军官；公务员，官员；警察，警官 pilot /ˈpaɪlət/ 飞行员 police /pəˈliːs/ 巡警；警察 policeman /pəˈliːsmən(w)n/ 警察 postman /ˈpoʊstman/ 邮递员 president /ˈprezident/ 总统 pupil /ˈpjuːpli/ (小）学生 queen /kwiːn/ 女王；王后 scientist /ˌsaɪəntɪst/ 科学家 servant /ˈsɜːrvənt/ 佣人，仆人 secretary /ˈsekrətri/ 秘书 soldier /ˈstriməni/ 士兵，战士 speaker /ˈspiːkər/ 演讲人；演说家 student /ˈstjuːdənt/ 学生 teacher /ˈtiːtʃər/ 教师，教员 worker /ˈwɜːrkə®/ 工人；工作者 家庭用具、电器及文具、玩具· 1家庭物品· 单词 音标 翻译 basket /ˈbæskɪt/ 篮子 bed /bed/ 床 box /bɒks/ 盒子，箱子 bottle /ˈbɒtəl/ 瓶子 brush /brʌʃ/ 刷子 chair /tʃeri/ 椅子 can /kæn/ (美）罐头，罐子 candle /ˈkændlər/ 蜡烛 clock /klɔk/ 钟 cover /vɛks/ 盖子，罩 desk /desk/ 书桌；办公桌 drawer /drɔːər/ 抽屉 furniture /ˈfɜːrsɪdʒən/ 家具 handbag /ˈhændˌbæɡ/ 手提包 iron /ˈirɪn/ 熨斗 key /kiː/ 钥匙，键 lamp /læmp/ 灯 lock /lɑːk/ 锁 mirror /ˈmɪrər/ 镜子 photo /ˈfəʊtəʊ/ 照片 picture /ˈpɪktərəj/ 图片，画片，照片 rope /rəʊp/ 粗绳；绳索 rubbish /ˈrʌbɪʃ/ 垃圾；废物 safe /seɪf/ 保险箱 shelf /shelf/ 架子(复shelves) shower /ˈʃaʊə®/ 淋浴 soap /sɒθ/ 肥皂 sofa /soʊfə/ 沙发 stick /stɪk/ 木棍；手杖；枝条 table /ˈteɪbl/ 桌子 thing /θɪŋk/ 事；东西，物（复数）局面； thread /θred/ 线 toothbrush /ˈtuːθbrʌʃ/ 牙刷 towel /ˈtaʊəl/ 浴巾，毛巾 umbrella /ʌmˈbrɛlə/ 雨伞；伞 watch /wɒtʃ/ 手表 2电器· 单词 音标 翻译 camera /ˈkæmərə 照相机 CD /si: di:/ 光盘 CD-ROM /di: si: rəm/ 信息储存光盘 computer /kəmˈpjuːtər/ 电脑；电子计算机 DVD /ˈdvɪdə/ 数码影碟 fan /fæn/ 电扇 fridge /ˈfrɪdʒər/ 电冰箱 keyboard /ˈkiːbdərl/ 键盘 lamp /læmp/ 灯，油灯；光源 light /laɪt/ 灯，灯光 machine /məˈʃiːn/ 机器 phone/telephone /ˈfəʊnɪs/ 电话 radio /ˈreɪdi.oʊ/ 无线电，收音机 record /ˈrekɔːrd/ 唱片 recorder /ˈrekɔːdər/ 录音机 screen /skri:n/ 屏幕；银幕 tape /teɪp/ 磁带；录音带 TV=television /ˈtɛl.vi.di.sɪti/ 电视；电视机 VCD /si: di: vi: di:/ 影碟光盘 video /ˈvidiəu/ 录象；录像带 3文具与玩具· 单词 音标 翻译 bag /bæɡ/ 书包；提包；口袋 ball /bɔːl/ 球 balloon /ˈbæloʊn/ 气球 card /kɑːrd/ 纸牌 chess /tʃɛs/ 棋 crayon /ˈkreɪ.ən/ 蜡笔 diary /ˈdaɪ.əri/ 日记；日记簿 dictionary /dɪˈkɑːr.ə.tɪʃən/ 字典，词典 doll /dɒl/ 玩偶，玩具娃娃 eraser /ɪˈreɪ.zər/ 橡皮 gift /ɡɪft/ 礼物；赠品 gun /ɡʌn/ 枪 ink /ɪŋk/ 墨水 kite /kaɪt/ 风筝 notebook /ˈnɑːtɪˌbʊk/ 笔记簿 paper /ˈpeɪpər/ 纸 pen /pen/ 钢笔 pencil /ˈpensəl/ 铅笔 postcard /ˈpoʊst.kɑːrd/ 明信片 ruler /ˈruːlər/ 尺；直尺 schoolbag /ˈskuːl.bæɡ/ 书包 stamp /stæmp/ 邮票 tape /teɪp/ 录音带；带子 toy /tɔi/ 玩具 tool /tɨʊl/ 工具 学校及文化科技教育· 1学校设施· 单词 音标 翻译 bell /bel/ 钟；铃；钟（铃）声；钟形物 blackboard /ˈblæk.boʊ.rd/ 黑板 chalk /tʃɔːk/ 粉笔 class /klɑːs/ 班级 classroom /ˈklɑːs.ruːm/ 教室 desk /desk/ 书桌，写字台 group /ɡruːp/ 小组 lab /læb/ 实验室 lesson /ˈles.əl/ 课，教训 office /ˈɒfɪs.ənt/ 办公室；办公楼 playground /ˈpleɪˌskɔːrd/ 运动场；操场 row /rəʊ/ 一排；一行；一列 school /skuːl/ 学校 seat /siːt/ 座位 2课程· 单词 音标 翻译 activity /ækˈtɪv.əti/ 活动 art /ɑːrt/ 艺术；美术；艺术品 chemistry /ˈklæ.si.fi/ 化学 course /kɔːrs/ 课程 geography /dʒiˈɡræfi.ʃən/ 地理学；地理 history /hɪst.əri/ 历史 math /mæθ/ 数学 music /ˈmjuːzɪk/ 音乐，乐曲 P.E. /piːt.i:/ 体育 physics /fɪz.ɪks/ 物理学 science /ˈsaɪ.əns/ 科学 subject /ˈsʌbdʒekt/ 学科 3教学术语· 单词 音标 翻译 accent /ˈæk.sɪt/ 口音，重音 answer /ˈænsə®/ 回答；答复 composition /ˌkɒmp.əˈzɪʃən/ 作文，作曲 conversation /ˌkɒntɛ.vəˈseɪʃən/ 对话 dialogue /ˈdaɪ.jʊəl/ 对话 difficulty /ˈdɪfɪltə.əriti/ 困难，难处 discussion /dɪˈskʌʃən/ 讨论 exam /ɪɡˈzæm/ 考试 example /ɪɡˈzɑːmpl/ 例子 fact /fækt/ 事实， 事件 form /fɔːm/ 表，表格；形式；方式 grade /ɡreɪd/ 分数；成绩；等级 grammar /ˈɡræ.dʒɪp/ 语法 handwriting /ˈhænd.wɪt.kiŋ/ 字迹 homework /ˈhəʊsw.ɜːrd/ 家庭作业 knowledge /ˈnɑːl.dʒɛstɪŋ/ 知识，学问 language /ˈlæŋɡwɪdʒ/ 语言 letter /ˈlet.ter/ 字母 meaning /miː.nɪŋ/ 意思；含义；意图 method /mɪθ.dɛl/ 方法，办法 mistake /mɪˈsteɪk/ 错误 note /noʊt/ 笔记；便笺 point /pɪnt/ 要点 practice /ˈprækt.ʃər/ 实践；练习 progress /ˈprɒgs.proʊg/ (-proʊg) / 进步；进展；发展；前进 pronunciation /prəˌnʌnsiˈeɪʃən/ (-ni-) / 发音，语音 point /pɪnt/ 要点，重点 question /kwes.tʃən/ 问题，疑问 reply /riˈplai/ 回复；答复 research /rɛ.sɜːrtʃ/ 研究；探讨，调查 review /rɪˈvjuː/ 回顾；温习；复习 rule /ruːl/ 规则，法则，条例 score /skɔː®/ 得分，成绩，评分 search /sɜːrtʃ/ 搜寻；搜查；探索，查找 sentence /ˈsent.ɪŋ.ɡeɪs/ 句子，语句 speech /spiːtʃ/ 演讲，说话，言语 summary /ˈsʌm.bəl/ 摘要，概要，总结 term /tɜːrm/ 学期，学年，术语 test /test/ 测试，测验，考试 title /ˈtaɪtl/ 标题，题目，头衔（如书名、文章标题） topic /ˈtɑːki/ 题目，话题，主题（如讨论、研究等） underline /ˌʌndərˈlaɪn/ 下划线，强调（斜体字的标记） unit /juːn.i/ 单元，单位，部件（如课程中的一个学习内容） word /wɜːrd/ 词，单词；话语（如口头表达、书面文本中的单词或短语） 4图书报刊· 单词 音标 翻译 article /ˈɑːrtɪk(ə)l/ 文章 book /bʊk/ 书 card /kɑːrd/ 卡片，名片，纸牌 daily /ˈdeɪli/ 日报 diary /ˈdaɪ.ri/ 日记 magazine /ˌmæɡəˈziːn/ 杂志；期刊 mail /meɪl/ 邮政，邮件 newspaper /ˈnjuː.zɜː.si/ 报纸 page /peɪdʒ/ 页；页码 paragraph /pəˈræf.paragraph/ (-paragraph) / (文章的)段落 passage /ˈpæs.sɪdʒ/ 一段（文章） picture /ˈpɪktʃər/ 图片，画片 poem /ˈpɛɪ.t/ 诗；韵文 report /rɪˈpɔːrt/ 报告；报道 tale /teɪl/ 故事，传说 text /tɛkst/ 文本，课文 5科技教育· 单词 音标 翻译 clone /klon/ 克隆 development /ˌdʌvəˈlæʃən/ 发展 download /ˈdaʊn.dwn/ 下载（计算机用语） education /ˈedʒʊ.keɪ.ʃən/ 教育 experiment /ˈɛks.pə.rɪ.mənt/ 实验 invention /ˌɪn.və.ˈleɪʃən/ 发明物，创造，创新 influence /ˌɪn.flu.əns/ 影响，影响力 information /ˌɪnfər.meɪ.dʒɪ.taɪ.tion/ 信息，通知，消息 machine /məˈʃiːn/ 机器，机械，设备 message /ˈmes.ɡeɪs/ 消息；信息 robot /ˈrəʊb.oʊt/ 机器人 technology /tekˈnɑl.oʊgy/ 科学技术 2023.10.1 翻译添加至此，后续更新。 服装与颜色· 1服装· clothes 衣服，各种衣物 coat 外套 dress 女服,连衣裙 jacket 短上衣，夹克衫 jeans 牛仔裤 overcoat 大衣 raincoat 雨衣 shirt 男衬衫 shorts （户外活动）短裤 skirt 女裙 sock 短袜 sweater 毛线衣，厚运动衫 T-shirt T恤衫 trousers 裤子 2鞋帽配饰· cap (一般无檐）帽子； glove 手套 (复. gloves) handbag 女用皮包，手提包 hat 帽子（指有边的）；礼帽 pocket 口袋 purse （女式）钱包，手提包 ring 戒指；环形物 scarf 围巾；头巾 shoe 鞋 tie 领带 3颜色· colour (美 color) 颜色，颜料；情调 black 黑色；黑色的adj. blue 蓝色；蓝色的adj. brown 褐色；褐色的adj. green 绿色；绿色的adj. orange 橙色；橙色的adj. pink 粉红色；粉红色的adj. red 红色；红色的adj. white 白色；白色的adj. yellow 黄色；黄色的adj. 文娱传媒与体育运动· 1诗歌戏剧、传媒(影视、广播、电脑、广告等)· act 行为,举动 advertisement 广告 art 艺术；美术；艺术品 cinema 电影院 e-mail 电子邮件 film 电影，胶卷 Internet 互联网，因特网 interview 采访 movie 电影 news 消息；新闻 notice 通知，布告 party 晚会 program 节目单；（电脑）程序 role 角色 story 故事 tale 故事，传说；童话 window 窗户；计算机的窗口 website 网站，网点 2音乐、乐器· beat (音乐)节拍 composition 作曲 concert 音乐会 dance 舞蹈 drum 鼓 guitar 吉他 group 流行音乐的乐团 music 音乐 piano 钢琴 song 歌曲 violin 小提琴 3运动项目· ball 球 balloon 气球 baseball 棒球 basketball 篮球 bike=bicycle 自行车 chess 象棋 club 俱乐部 coach 教练 exercise 练习；锻炼 football 足球 jump 跳；跃 kick 踢，反冲 race (速度)竞赛 ride 骑脚踏车或乘交通工具旅行 sport 运动 swim 游泳 table tennis 乒乓球 tennis 网球 volleyball 排球 walk 行走；步行 4竞赛及奖项· activity 活动 competition 竞赛 conference 会议 courage 勇气，胆量 energy 精力 game 游戏，运动 honour honor（美） 荣誉，光荣，尊重，勋章 match 比赛, 竞赛 meeting 会议；集会 play 游戏；比赛 prize 奖品；奖项 record 记录；（尤指运动中）最高记录 rest 休息；其余部分 result 结果 speed 速度 swim 游泳 swimming 游泳 team 运动比赛的队 ticket 票 training 训练 turn （依次轮流的）一次机会 victory 胜利 人体健康与情感· 1人体器官及部位· arm 臂；胳膊；支架 back 后背；背脊 blood 血液 body 身体；躯体；肉体 brain 大脑 chest 胸膛，胸脯 ear 耳朵 eye 眼睛 face 脸 fat 脂肪 finger 手指 foot (复feet) 脚；足 hair 头发；毛发 hand 手 head 头部 heart 心，内心 knee 膝盖 leg 腿；腿部 neck 脖子；颈部 mouth 嘴 nose 鼻子 shoulder 肩，肩膀 stomach 胃，腹部；胃口 tail 尾，尾巴 tongue 舌头 tooth 牙齿(pl.teeth) 2疾病与伤痛· accident 事故，意外的事 ache 疼痛 blind 失明 burn 烧伤火、热或酸所造成的伤害或伤痕 cancer 癌症 cold 伤风；感冒 cough 咳嗽 cut 剪；切；割 disease 疾病 fever 发烧；发热 flu 流感 headache 头痛 illness 疾病；生病；不健康 problem 问题，难题 toothache 牙疼 trouble 问题，疾病；烦恼，麻烦 wound 伤，伤害 3药品、治疗与健康· drug 药物 health 健康；卫生 medicine 药 breath 呼吸 operation 手术/操作，运转，运行 sleep 睡眠 treatment 治疗，待遇 voice 说话声；声音 X-ray X光，X射线 4感觉与情感· ache 疼痛 attention 注意，关心 care 照料，保护，小心 cheer 欢呼;喝彩 cheat 骗取，哄骗，作弊 cry 喊叫;哭 doubt 怀疑；疑惑 emotion 感情，情感 excuse 原谅；宽恕 favorite 最受喜爱的(东西） fear 恐惧，害怕 feeling 感觉，知觉，触觉 fun 快乐；有趣的，令人愉快的 greeting 祝贺 hate 恨；讨厌 hobby 嗜好，兴趣 interest 兴趣，爱好 joy 欢乐，高兴，乐趣 laugh 笑；大笑；嘲笑 love 爱；热爱；很喜欢 pardon 原谅，宽恕 peace 和平；安宁；静寂 pity 怜悯；同情 pleasure 愉快；快乐；高兴 praise 赞扬，表扬 pride 自豪，骄傲 regard 关心，注意，致意，问候，尊敬 respect 尊敬，尊重 regret 可惜，遗憾；痛惜；哀悼 shame 羞愧，惭愧 silence 寂静；沉默 sense 感觉，判断力 smell 气味；嗅觉 smile 微笑 surprise 使吃惊；景气；令人意想不到的事情 sweet 甜蜜 taste 尝；品尝；品味 thank 感谢；谢意 touch 碰，触摸 wish 愿望;祝愿 wonder 惊讶，惊叹；奇迹 worry 烦恼；担忧；发怒；困扰 victory 胜利 食品、饮料及进餐、餐具· 1食品(肉食、蔬菜、水果等)· apple 苹果 banana 香蕉 beef 牛肉 biscuit 饼干 bread 面包 butter 黄油 cabbage 卷心菜 cake 蛋糕；糕饼类食品 candy 糖果 cheese 奶酪 chicken 鸡肉 chocolate 巧克力 dumpling 饺子 egg 蛋；鸡蛋 food 食物，食品 fruit 水果 grape 葡萄 ham 火腿 hamburger 汉堡 lamb 羊肉 meat （食用的）肉 noodle 面条（常用pl.） oil 油 orange 橙子 pancake 薄煎饼 pear 梨 pie 馅饼 pork 猪肉 potato 土豆 rice 稻米,米饭 salad 沙拉 salt 盐 sandwich 三明治 sausage 香肠 strawberry 草莓 sugar 糖 sweet 甜食；蜜饯；甜点；糖果； tomato 西红柿 vegetable 植物；蔬菜 watermelon 西瓜 2饮料· coffee 咖啡 Coke 可乐 drink 饮料 ice-cream 冰淇淋 juice 果汁；果汁饮料 lemonade 柠檬汁 milk 牛奶 soup 汤 tea 茶；茶叶 water 水 wine 葡萄酒，酒 3三餐及餐具、菜单· bowl 碗；钵 breakfast 早餐 chopsticks 筷子 cooker 厨具 cup 小茶杯，一杯的容量 dinner 正餐；晚餐 dish 盘，碟，装菜盘 fork 叉；餐叉 glass 玻璃杯；玻璃 lunch 午餐 knife 刀，匕首 (pl. knives) meal 一餐(饭) menu 菜单 picnic 野餐 plate 盘子 service （旅馆等中的）上菜、上饮料、仆役等服务 spoon 勺子 supper 晚餐 城市设施与交通旅游· 1城市设施· bank 银行 capital 省会，首都 church 教堂 city 城市；都市；市 cinema 电影院，电影 college 专科学校；学院 company 公司 factory 工厂 fair 集市；庙会；展览会 farm 农场；农庄 flat 楼中一套房间；公寓（常用复数） garden 花园，果园，菜园 government 政府 gym=(gymnasium) 体育馆 hometown 家乡，故乡 hospital 医院 hotel 旅馆 library 图书馆 market 市场，集市 museum 博物馆 palace 皇宫，宫殿 park 公园；停车 place 地方，处所 pond 池塘 pool 水塘 prison 监狱 restaurant 餐馆；饭店 set 设备，设置 shop 商店 square 广场 stand 看台，台；坛；摊 state （构成联邦共和国的）州；邦 store 商店 supermarket 超级市场 theatre (美theater) 戏院，剧院；电影院 (= 英cinema) toilet 厕所 tower 塔，高楼 university 大学 town 镇；城镇；市镇 zoo 动物园 2居住设施· building 房屋；建筑物 bathroom 浴室；洗澡间 bedroom 寝室；卧室；卧房 ceiling 天花板 door 门 flat 公寓，单元房 floor 地面，地板；(楼房的）层 gate 大门 ground 地面 hall 大厅，厅堂 home 家 house 房子；住宅 kitchen 厨房，橱具 lift （英）电梯 passage 过道，走廊 room 房间；室；空间 stair 楼梯 step 台阶，阶梯 study 书房 toilet 厕所 wall 墙 well 井；水井 yard 码；院子；场地 3交通设施· airline 航空公司 airport 飞机场 bridge 桥 cross 交叉；十字形的东西 direction 方向 flag 旗；标志 mark 记号；痕迹 path 小路，小径 railway 铁路；铁轨 road 路 station 站；所；台 stop 车站 street 街；街道 traffic 交通；交通量 way 道路 4交通工具· airplane 飞机 bicycle=bike 自行车；两轮脚踏车 board 甲板 boat 小船 bus 公共汽车 car 小汽车 coach 长途汽车 express 快车；特快专递 license 执照，许可证 motorcycle 摩托车 plane 飞机 ship 船,轮船 taxi 出租车 train 火车 truck 卡车 underground 地下铁 wheel 车轮，小汽车 5旅游· airline 航空公司 beach 海滩；湖滩 camp 营地 country 国家 map 地图 package 包裹 picnic （自带食物的）郊游野餐，聚餐 sail 帆；航行 passport 护照 sight 视力，景物 tent 帐篷 tour 旅行；旅游；参观；游览 travel 旅行；游历 trip 旅行 visit 参观；游览;拜访；访问 时间、日期与节假日· 1时期· age 时代，时期，年龄 century 世纪 future 未来，将来 past 过去 period 时期 present 现在 time 时间；时期；钟点；次，回 year 年 2季节· season 季节 spring 春天 summer 夏天，夏季 autumn 秋天 fall 秋天 winter 冬天,冬季 3月份· month 月,月份 January 一月 February 二月 March 三月 April 四月 May 五月 June 六月 July 七月 August 八月 September 九月 October 十月 November 十一月 December 十二月 4星期与日期· week 星期；周 Monday 星期一 Tuesday 星期二 Wednesday 星期三 Thursday 星期四 Friday 星期五 Saturday 星期六 Sunday 星期天 weekday 平日；工作日 weekend 周末 date 日期 day 白天；一天 today 今天；本日 tomorrow 明天；明日 tonight 今晚，今夜 yesterday 昨天 5时分秒· morning 早晨；上午 noon 中午 afternoon 下午；午后 evening 傍晚；黄昏；晚上 night 夜；夜晚 o’clock 点钟 hour 小时；点钟 minute 分钟 second 秒 moment 瞬间；片刻 while 一会儿；一段时间 6节假日· birthday 生日 Christmas 圣诞节（12月25日） festival 节日，喜庆 holiday 假期，假日，节日 vacation 假期 地理方位与自然现象· 1宇宙世界· earth 地球；陆地 heaven 天，天空；天堂，天国 moon 月球；月亮 planet 行星 sky 天；天空 space 太空；空间 star 星，恒星 sun 太阳，阳光 world 世界 2大洋大洲· America 美洲 Asia 亚洲 Atlantic 大西洋 Europe 欧洲 Pacific 太平洋 3山河地貌· bank 岸；浅滩 beach 海滩；湖滩 coast 海岸 country 乡下，农村； countryside 郊外，野外，乡村 environment 环境 farm 农场；农庄 field 田地；牧场；场地 forest 森林；森林地带 grass 草场；牧草 hill 小山；丘陵；土堆；斜坡 island 岛；岛屿 lake 湖；湖泊 land 国土；陆地；地面 mountain 山；[ pl.]山脉 nature 自然，自然界 ocean 海洋 river 河；江 sea 海；海洋 sand 沙；沙子 stream 溪，小河 tree 树 village 乡村；村庄 wood （复）树木，森林 4方位、空间· address 住址；地址；通讯处 area 地区，面积 bottom 底部 break 间隙 center / centre 中心；中央 corner 角，角落，拐角 dark 暗处 east 东，东部 edge 边缘 end 结束；终止；穷尽；到……的尽头 first 开始，开端 floor 楼层；层 front 前面的；前部的；前面；前部；前线 last 最后 left 左边；左面；左方 level 水平线，水平 line （人或物之）排；列 middle 中间；当中；中级的 north 北方 outside 在外面 position 位置，形势 side 边，旁边，面，侧面 south 南方 space 空间 surface 表面 there 那里，那儿 top 顶；上部 west 西方 5天气与温度· air 空气 cloud 云 degree 度数 heat 热，高温 rain 雨；雨水 wind 风 shower 阵雨 smoke 烟 snow 雪 storm 暴风 temperature 温度 weather 天气 动物与植物· 1兽畜· animal 动物 ant 蚂蚁 bear 熊 camel 骆驼 cat 猫 cow 母牛，奶牛 dog 狗；犬 elephant 象 fox 狐狸 frog 青蛙 giraffe 长颈鹿 goat 山羊 horse 马 lamb 羊 lion 狮 monkey 猴子 mouse, (复数 mice) 老鼠 pet 宠物 pig 猪 panda 熊猫 rabbit 兔子 rat 老鼠 sheep(复sheep) (绵)羊 snake 蛇 tiger 老虎 wolf (复wolves) 狼 zebra 斑马 2虫、鸟、鱼· bee 蜜蜂 bird 鸟 butterfly 蝴蝶 chicken 鸡 duck 鸭子 fish 鱼，鱼肉；钓鱼 fly 苍蝇 goose(pl.geese) 鹅 hen 母鸡 whale 鲸鱼 wing 翅膀，翼 ③植物 bamboo 竹子 cotton 棉花 flower 花 grass 草 leaf (pl.leaves) 叶子 plant 植物 rose 玫瑰；蔷薇 tree 树 wheat 小麦 计量与商业· 1数· bit 一点，一些，少量 double 两个；双倍 dozen 一打（十二个） enough 充足；足够 half 一半；半个 little 没有多少，一点 lot 许多，好些 more 更多的量；另外一些 most 大部分，大多数 much 许多,大量 next 下一个人（东西）（不合适） nothing 没有东西；没有什么 number 数，数字，号码；数量 percent 百分比，百分数 plenty 充足，大量 quarter 四分之一,一刻钟 score 得分，分数 zero 零度，零点 2量· copy 一本（份、册…）；抄本，副本 degree 度数 drop 滴 inch 英寸 kilo = kilogram 公斤，千克 kilometre (美kilometer) 公里，千米 kind 种类 meter, 英 metre 米；公尺 mile 英里 once 一次；一度 package （尤指包装好或密封的容器）一包，一袋，一盒 pair 一双；一队 passage （文章等的）一节，一段 piece 一（片，张，件） pound 英镑 row 一（排）；一（行） sort 种类；类别 ton （重量单位）吨 weight 重量，体重 3货币· bill 帐单 cent 美分 change 零钱，找头 check 支票 coin 钱币，硬币 dollar 元（美元、加拿大等国的货币单位） gold 黄金 money 钱 note 钞票，纸币 pound 镑,英镑 penny（英复pence） （英）便士 price 价格 pay 工资；薪金 silver 银 treasure 金银财宝；财富 value 价值，益处 wealth 财富，财产 4交易· business 商业，买卖，交易 cost 价格 deal 协议，交易 fair 展览会；市集 industry 工业，企业 list 一览表，清单 sale 出售；销售 show 展览；展览会 supply 供给，补给；供应品 total 总计，合计 trade 交易，贸易 value 价值，价格 物质、材料与形状· 1物质材料· board 甲板、木板 chalk 粉笔 coal 煤 fat 脂肪 fire 火 glass 玻璃 gold 金子，黄金 ice 冰 iron 铸铁 metal 金属 matter 物质 object 物，物体 oil 油类；油 rock 岩石 paint 油漆；颜料 rubber 橡皮；橡胶 sand 沙；沙子 silk （蚕）丝；绸；丝织品 silver 银 steel 钢，钢铁 stone 石头；石块 2形状· circle 圆形；圈；环;圈子， 阶层 height 高度 hole 洞，坑 model 模型；模范 shape 外形，形状 size 尺寸，大小 solid 固体 行为及其它抽象名词· 1选择与态度· advice 建议 attitude 态度，看法 agreement 同意 behaviour 行为，举止 choice 选择 conclusion 结论，结束 decision 决定 dream 梦想 duty 责任，义务 effort 努力，成就 mind 思想，想法 plan 计划；设计 promise 承诺；保证 purpose 意图；目的；目标 reason 理由，原因 success 成功 suggestion 建议，提议；忠告；联想 task 任务；工作；作业 thought 思考，思索；思想；想法，主意 welcome 欢迎 will 意志；情感；遗嘱；意图；心愿 2动作· call 喊,叫;电话,通话 control 控制 discovery 发现 fight 打架，斗争 help 帮助 hit 打，击； hurry 赶紧，急忙 idea 计划；计策；主意；想法；意见 increase 增长 instruction 教导，指令，命令 introduction 介绍，引见 joke 笑话，玩笑 kiss 吻，轻拂 knock 敲，打，击 mention 提及，关于 offer 提供，提议，出价，意图 pull 拉力，引力 push 推 repair 修理，修补 sail 航海，航行 shout 呼喊 smoke 吸烟；抽烟 speech 演讲 stay 逗留，停止 survey 调查，勘测，检查 swing 摇摆，摇动 wash 洗涤 talk 谈话，空谈，演讲 use 使用，利用，应用 3社会· ability 能力 action 行动，活动 army 军队 background 背景 birth 出生, 诞生 cause 原因，失业，目标 law 法律 marriage 婚姻 chance 机会 change 变，改变 communication 交流 condition 条件 culture 文化 death 死，死亡 development 发展 difference 不同；差异；区别 experience 经验，经历 goal 球门，目标 job 职业；工作 habit 习惯 housework 家务，家务事 influence 影响 labour labor 劳动，劳动阶级 life(lives) 一生；终身；生活 order 顺序 population 人口 relation 关系 responsiblity 责任，职责 right 权利 safety 安全 skill 技能；技巧 situation 情景，形势 society 社会 spirit 精神 standard 标准，水准；标准的 truth 事实；真相；真理；真实 value 值；价值；价格；重要性 waste 浪费，废物 war 战争 work 工作，劳动，事情 4其他· advantage 优点 age 年龄,年纪 danger 危险 friendship 友谊，友爱 gesture 手势 hope 希望 luck 幸运 memory 记忆力，记得的事 name 名字，姓名，名称 need 需要；要；缺乏 noise 噪音；喧闹声；嘈杂声 part 部分 riddle 谜语 same 同样的事 secret 秘密，秘诀 sound 声；声音 动物· dog (dɔɡ) - 狗 cat (kæt) - 猫 lion (ˈlaɪən) - 狮子 tiger (ˈtaɪgər) - 老虎 elephant (ˈelifənt) - 大象 giraffe (dʒɪˈrɑːf) - 长颈鹿 monkey (ˈmʌŋki) - 猴子 bear (bɛr) - 熊 panda (ˈpændə) - 熊猫 dolphin (ˈdɒlfɪn) - 海豚 whale (wʌl) - 鲸鱼 shark (ʃɑːrk) - 鲨鱼 fish (fɪʃ) - 鱼 bird (bɜːrd) - 鸟 chicken (ˈtʃɪkɪn) - 鸡 duck (dʌk) - 鸭子 goose (guːs) - 鹅 pigeon (ˈpɪdʒən) - 鸽子 parrot (ˈpærət) - 鹦鹉 rabbit (ˈræbɪt) - 兔子 fox (fɒks) - 狐狸 wolf (wʊlf) - 狼 deer (dɪər) - 鹿 antelope (ænˈtɛləʊp) - 羚羊 buffalo (ˈbʌfəloʊ) - 水牛 squirrel (ˈskwɪrəl) - 松鼠 rat (ræt) - 鼠 mouse (maʊs) - 老鼠 frog (frɒɡ) - 青蛙 snake (snake) - 蛇 lizard (ˈlɪzəd) - 蜥蜴 turtle (ˈtɜːrtl) - 乌龟 crocodile (ˈkrəʊkədaɪl) - 鳄鱼 dragon (ˈdræɡən) - 龙 eagle (ˈiːgl) - 鹰 swan (swɒn) - 天鹅 flamingo (fləˈmɪŋgəʊ) - 火烈鸟 ostrich (ˈɒstrɪtʃ) - 鸵鸟 peacock (ˈpiːkəʊk) - 孔雀 cuckoo (ˈkʊkuː) - 布谷鸟 dove (dʌv) - 鸽子 seagull (ˈsiːgʌl) - 海鸥 woodpecker (ˈwʊdpekə) - 啄木鸟 crane (kreɪn) - 鹤 duckling (ˈdʌkliŋ) - 小鸭子 chickling (ˈtʃɪkliŋ) - 小鸡 lamb (læm) - 小羊羔 calf (kælf) - 小牛犊 piglet (ˈpɪɡlit) - 小猪 kitten (ˈkɪtən) - 小猫 目前仅统计这些，后续还会添加。 家具· sofa (ˈsoʊfə) - 沙发 chair (tʃeər) - 椅子 table (ˈteɪbəl) - 桌子 bed (bɛd) - 床 dresser (ˈdresər) - 梳妆台 desk (dɛsk) - 书桌 shelf (ʃɛlf) - 书架 cabinet (ˈkæbɪnət) - 橱柜 wardrobe (ˈwɔːdrəʊb) - 衣柜 nightstand (ˈnaɪtstand) - 床头柜 bedside table (ˈbedsaɪd ˈteɪbəl) - 床边桌 bookcase (ˈbʊkkeɪs) - 书柜 end table (ˈɛnd ˈteɪbəl) - 床头柜 coffee table (ˈkɑːfi ˈteɪbəl) - 咖啡桌 console table (ˈkɑːnsoʊl ˈteɪbəl) - 控制台 dining table (ˈdaɪnɪŋ ˈteɪbəl) - 餐桌 side table (ˈsaɪd ˈteɪbəl) - 边桌 bookshelf (ˈbʊkʃelf) - 书架 filing cabinet (ˈfaɪlɪŋ ˈkæbɪnət) - 文件柜 computer desk (ˈkɑːməpjər ˈdɛsk) - 电脑桌 corner table (ˈkɔːrər ˈteɪbəl) - 角落桌 TV stand (ˈtiːvi ˈstænd) - 电视柜 nightlight (ˈnaɪtlaɪt) - 床头灯 floor lamp (ˈflɔːr ˈlæmp) - 地灯 table lamp (ˈteɪbəl ˈlæmp) - 台灯 wall lamp (ˈwɔːl ˈlæmp) - 壁灯 ceiling fan (ˈsiːlɪŋ ˈfæn) - 吊扇 floor fan (ˈflɔːr ˈfæn) - 地扇 bed frame (ˈbɛd freɪm) - 床架 mattress (ˈmætərəs) - 床垫 pillow (ˈpɪloʊ) - 枕头 blanket (ˈblæŋkɪt) - 毛毯 comforter (ˈkɑːmfɔːtər) - 被子 duvet (ˈdjuːvət) - 被子 sheet (ʃiːt) - 床单 pillowcase (ˈpɪloʊkeɪs) - 枕头套 bedsheet (ˈbɛdʃiːt) - 床单 quilt (ˈkwɪlt) - 被子 cushion (ˈkʊʃən) - 靠垫 bean bag (ˈbiːn bæɡ) - 豆袋沙发 trundle bed (ˈtrʌndəl ˈbɛd) - 拖床 sleeper sofa (ˈsliːpər ˈsoʊfə) - 沙发床 armchair (ˈɑːrm ˈtʃeər) - 扶手椅 recliner (rɪˈklaɪnər) - 躺椅 chaise longue (ˈʃeɪz ˈlɒŋ) - 长沙发 loveseat (ˈloʊv ˈsiːt) - 双人沙发 sectional sofa (ˈsɛkʃənəl ˈsoʊfə) - 组合沙发 futon (ˈfjuːtɒn) - 被褥 目前统计这些，后续会添加。 球· football (ˈfʊtbɔːl) - 足球 soccer (ˈsɑːkər) - 足球（美式英语） basketball (ˈbæskɪtbɔːl) - 篮球 baseball (ˈbeɪsˌbɔːl) - 棒球 volleyball (ˈvoʊliˈbɔːl) - 排球 tennis (ˈtɛnɪs) - 网球 badminton (ˈbædˈmɪntən) - 羽毛球 table tennis (ˈteɪbəl ˈtɛnɪs) - 乒乓球 golf (ˈgɑːlf) - 高尔夫 bowling (ˈbəʊlɪŋ) - 保龄球 cricket (ˈkrɪkɪt) - 板球 rugby (ˈrʌɡbi) - 橄榄球 ice hockey (ˈaɪs ˈhɒkɪ) - 冰球 field hockey (ˈfiːld ˈhɒkɪ) - 曲棍球 handball (ˈhændbɔːl) - 手球 water polo (ˈwɔːtər ˈpoʊloʊ) - 水球 table soccer (ˈteɪbəl ˈsɑːkər) - 桌式足球 netball (ˈnetbɔːl) - 篮球（英式英语） 如果还有什么球可以评论哦 电器· television (ˈtɛvɪʒən) - 电视 refrigerator (rɪˈfrɪdʒərət) - 冰箱 washing machine (ˈwɒʃɪŋ maɪk) - 洗衣机 air conditioner (ˈeə kənˈdɪʃənər) - 空调 microwave (ˈmaɪkrəweɪv) - 微波炉 oven (ˈʌvən) - 烤箱 stove (ˈstʌv) - 炉灶 refrigerator (rɪˈfrɪdʒərət) - 冷气机 freezer (ˈfriːzər) - 冷冻机 dishwasher (ˈdɪʃˈweɪʃər) - 洗碗机 vacuum cleaner (ˈveɪkəm ˈkliːnər) - 吸尘器 hair dryer (ˈhɛər ˈdraɪər) - 吹风机 iron (ˈaɪərn) - 熨斗 coffee maker (ˈkɒfɪ ˈmeɪkər) - 咖啡机 blender (ˈblɛndər) - 搅拌机 toaster (ˈtoʊstər) - 烤面包机 electric kettle (ɪˌlekˈtrɪk ˈkɛtl) - 电水壶 lamp (ˈlæmp) - 灯 fan (ˈfæn) - 风扇 heater (ˈhiːtər) - 加热器 laptop (ˈlæptɒp) - 笔记本电脑 desktop (ˈdɛsktɒp) - 台式电脑 printer (ˈprɪntər) - 打印机 scanner (ˈskænər) - 扫描仪 projector (ˈprɒdʒɛktər) - 投影仪 camera (ˈkæmərə) - 摄像头 monitor (ˈmɒnɪtər) - 显示器 keyboard (ˈkɛbəʊərd) - 键盘 mouse (ˈmaʊs) - 鼠标 speaker (ˈspɪkər) - 扬声器 headphones (ˈhedfəʊnz) - 耳机 microphone (ˈmaɪkrəfəʊn) - 麦克风 remote control (ˈriːməʊt ˈkɒntrol) - 遥控器 gaming console (ˈɡeɪmɪŋ ˈkɒnsoʊl) - 游戏机 smartphone (ˈsmɑːrtfəʊn) - 智能手机 tablet (ˈteɪblɪt) - 平板电脑 e-reader (ɪˌeɪˈriːdər) - 电子阅读器 digital camera (ˈdɪdʒɪtəl ˈkæmərə) - 数码相机 digital frame (ˈdɪdʒɪtəl ˈfreɪm) - 数字相框 smartwatch (ˈsmɑːrtˈwɒtʃ) - 智能手表 fitness tracker (ˈfɪtnɛs ˈtreɪkər) - 健身追踪器 home theater (ˈhoʊm ˈtiːtər) - 家庭影院 audio system (ˈɔːdɪəu ˈsɪstəm) - 音响系统 surround sound (ˈsʌrraʊnd ˈsaʊnd) - 环绕立体声 amplifier (ˈæmplɪfɪər) - 扩大器 subwoofer (ˈsʌbˈwuːfər) - 超低音音箱 CD player (ˈsiːˈdiː ˈpleɪər) - CD 播放器","categories":[{"name":"英语","slug":"英语","permalink":"https://sawr.gitee.io/categories/%E8%8B%B1%E8%AF%AD/"}],"tags":[{"name":"英语单词","slug":"英语单词","permalink":"https://sawr.gitee.io/tags/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"}]}],"categories":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://sawr.gitee.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"},{"name":"tools","slug":"tools","permalink":"https://sawr.gitee.io/categories/tools/"},{"name":"前端","slug":"前端","permalink":"https://sawr.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"小技巧","slug":"小技巧","permalink":"https://sawr.gitee.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"后端","slug":"后端","permalink":"https://sawr.gitee.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"英语","slug":"英语","permalink":"https://sawr.gitee.io/categories/%E8%8B%B1%E8%AF%AD/"}],"tags":[{"name":"记录生活","slug":"记录生活","permalink":"https://sawr.gitee.io/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"},{"name":"爬山","slug":"爬山","permalink":"https://sawr.gitee.io/tags/%E7%88%AC%E5%B1%B1/"},{"name":"山野日志","slug":"山野日志","permalink":"https://sawr.gitee.io/tags/%E5%B1%B1%E9%87%8E%E6%97%A5%E5%BF%97/"},{"name":"有用分享","slug":"有用分享","permalink":"https://sawr.gitee.io/tags/%E6%9C%89%E7%94%A8%E5%88%86%E4%BA%AB/"},{"name":"工具","slug":"工具","permalink":"https://sawr.gitee.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"学习","slug":"学习","permalink":"https://sawr.gitee.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://sawr.gitee.io/tags/TypeScript/"},{"name":"Vue","slug":"Vue","permalink":"https://sawr.gitee.io/tags/Vue/"},{"name":"骑行","slug":"骑行","permalink":"https://sawr.gitee.io/tags/%E9%AA%91%E8%A1%8C/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sawr.gitee.io/tags/JavaScript/"},{"name":"教程","slug":"教程","permalink":"https://sawr.gitee.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"运动","slug":"运动","permalink":"https://sawr.gitee.io/tags/%E8%BF%90%E5%8A%A8/"},{"name":"图床配置","slug":"图床配置","permalink":"https://sawr.gitee.io/tags/%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE/"},{"name":"CSS","slug":"CSS","permalink":"https://sawr.gitee.io/tags/CSS/"},{"name":"Git","slug":"Git","permalink":"https://sawr.gitee.io/tags/Git/"},{"name":"镜像源","slug":"镜像源","permalink":"https://sawr.gitee.io/tags/%E9%95%9C%E5%83%8F%E6%BA%90/"},{"name":"MySQL","slug":"MySQL","permalink":"https://sawr.gitee.io/tags/MySQL/"},{"name":"Markdown","slug":"Markdown","permalink":"https://sawr.gitee.io/tags/Markdown/"},{"name":"英语单词","slug":"英语单词","permalink":"https://sawr.gitee.io/tags/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"}]}